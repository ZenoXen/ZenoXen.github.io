<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>CS-BTE如何控制英雄的产生</title>
    <url>/2021/04/15/CS-BTE%E5%A6%82%E4%BD%95%E6%8E%A7%E5%88%B6%E8%8B%B1%E9%9B%84%E7%9A%84%E4%BA%A7%E7%94%9F/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>如果你是个CSOL的上古玩家（12年及以前），一定知道当时很热门的生化模式3，也许你也跟我一样，希望自己变身人类英雄的概率增加，或者干脆每把都希望自己变英雄。当时已经有不少一些高仿CSOL的单机版了，比如CSO-NST，我也有玩过，不过当时啥也不懂，也不懂编程知识或者CS插件管理之类的（虽然现在还是没了解过CS插件这一套代码）。前几天搞到了一份CS-BTE大概15年左右的版本，还是老生化模式的数据，就琢磨着怎么让自己每盘都变成英雄，花了两个小时研究插件源码，终于搞定了，接下来把自己的经验说一下。</p>
<p>先声明本人不是专业的CS插件制作者，这次修改也只是为了满足自己小小的需求，所以就不要来问我其他的一些东西咋改了，我其他地方的代码都没看过。</p>
<p>注：事后发现并非所有CS-BTE版本都自带源码文件，找了好久也没发现CS-BTE是否有官网，Github上找了一圈也没有对应的项目，可能制作团队不打算开源吧…总之，如果没有源码文件，就可以放弃了…</p>
<h1 id="定位源码"><a href="#定位源码" class="headerlink" title="定位源码"></a>定位源码</h1><p>首先第一步，需要知道cs的插件都是用AMX MOD X来管理的，这项目在Github上还有repository，官方文档的api文档也比较齐全，总之，如果你想做half-life或者cs 1.6的插件，肯定绕不过它的。</p>
<p>进入cs根目录的cstrike\addons\amxmodx目录下。</p>
<p><img src="2.png" alt="2"></p>
<p>这里需要说明一下，plugin目录是用来保存编译过的cs插件，即amxx后缀的文件，scripting目录内则一般放源代码文件和代码编译器，scripting目录不是必须的，就算没这目录，cs也可以正常运行各种插件。</p>
<p>在我们继续下一步之前，你必须确认一下你的cs目录里有没有.sma后缀的文件，这种文件是amxmodx的源码文件，如果有这种文件，可以顺腾摸瓜找到僵尸模式的插件源码文件，比如我这版本里，僵尸模式3的代码文件叫做BTE_Zombie_Mod3.sma。</p>
<p>进入scripting目录，介绍一下，sourcecode目录是用来存放sma源码文件的，我们要修改的僵尸模式3的代码就在其中，而amxxmpc.exe是amxmodx的编译器，修改好代码后，我们需要使用这个编译器来将代码编译得到amxx文件。</p>
<p>上面这些是一些基本的概念，接下来就来看一下英雄产生的源码吧。</p>
<p>找到sourcecode目录内BTE ZombieMod3\ZombieMod3目录中的Public.sma文件。</p>
<p>搜索一下Make_First_Zombie函数，这个函数的主要作用就是在倒计时结束后产生一定数量的僵尸和英雄。</p>
<p>其中有一段这样的代码，具体是啥可以看一下我写的注释。</p>
<pre><code>//有30%的几率产生英雄
if(random_num(0, 9)&gt;6)
&#123;
    new szHeroMsg[128];
    
    //最少产生一个英雄
    new iZombieNum = 1;
    iZombieNum += random_num(0, iInGame / 10);
    iZombieNum += random_num(0, iInGame / 10 - 1);
    new iRan

    //随机选取iZombieNum个玩家，将他们变成英雄
    do
    &#123;
        iRan = GetRandomPlayer(2)
        if(!iRan)
            return

        if(!g_hero[iRan]) Make_Hero(iRan)

    &#125; while (--iZombieNum)
    
    new name[32]
    new iTotalHero = 0;
    new iSendMsg = 0;

    for (new id = 1; id &lt;33; id++)
    &#123;
        if (g_hero[id])
            iTotalHero += 1;
    &#125;

    for (new id = 1; id &lt;33; id++)
    &#123;
        if (g_hero[id])
        &#123;
            iTotalHero --
            get_user_name(id,name,31)
            format(szHeroMsg, 127, &quot;%s%s%s&quot;, szHeroMsg, name, iTotalHero ? &quot;, &quot; : &quot;&quot;)
            iSendMsg = 1;
        &#125;
    &#125;
    /*format(szHeroMsg,127,&quot;%L&quot;,LANG_PLAYER,&quot;BTE_ZB3_HEROINFO&quot;,szHeroMsg)
    if(iSendMsg) client_print(0,print_center,szHeroMsg)*/

    if (iSendMsg)
        ClientPrint(0, HUD_PRINTCENTER, &quot;#CSBTE_ZB3_HeroSelected&quot;, szHeroMsg);
&#125;
</code></pre>
<p>可以看到英雄不是每一局100%产生的，是有70%几率不产生的，如果你想要100%产生英雄，将第一个if的条件改为random(0, 9) &gt; -1即可，或者其他永久为true的条件也可以…</p>
<p>随后如果你想让自己变成英雄，可以用下面这段代码插入到new IRan后面。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;find_player函数可以用来找到一个玩家，第一个参数&quot;a&quot;代表通过名字来找玩家，第二个参数则是查询条件，比如我在游戏中使用的昵称叫&quot;zenox&quot;</span><br><span class="line">iRan &#x3D; find_player(&quot;a&quot;,&quot;zenox&quot;);</span><br><span class="line">&#x2F;&#x2F;Make_Hero方法是用来将一个玩家变成英雄的，你也可以自己去看看这函数</span><br><span class="line">if(!g_zombie[iRan]) Make_Hero(iRan);</span><br></pre></td></tr></table></figure>

<p>至于为什么要用if(!g_zombie[iRan])这个条件来判断，如果不加的话，会出现同时变僵尸和变英雄的神奇画面。</p>
<h1 id="编译和覆盖插件"><a href="#编译和覆盖插件" class="headerlink" title="编译和覆盖插件"></a>编译和覆盖插件</h1><p>回到cstrike\addons\amxmodx\scripting目录下，使用cmd进入这个目录，并使用下面这个指令来编译源码文件，为什么修改的是Public.sma，而编译的是BTE_Zombie_Mod3.sma呢？因为这个文件引用了Public.sma文件，编译它，就把Pulic.sma连带着一起编译了。</p>
<p>amxxpc.exe “sourcecode\BTE ZombieMod3\BTE_Zombie_Mod3.sma”</p>
<p>如果编译成功，最后应该会显示一个Done，至于Warning，这个就不管他了。</p>
<p><img src="3.png" alt="3"></p>
<p>随后应该可以在scripting目录下发现这个文件，这个amxx文件就是新编译的插件文件，接下来将其覆盖到cstrike\addons\amxmodx\plugins目录下即可。</p>
<p><img src="4.png" alt="4"></p>
<p>覆盖编译生成的amxx文件到cstrike\addons\amxmodx\plugins目录下，如下所示。</p>
<p><img src="5.png" alt="5"></p>
<p>随后，进游戏试试看，你应该可以每把都变英雄了…当然这里只是简单修改一下英雄产生的逻辑，如果你有自己的想法，也可以改成自己想要的样子。</p>
<h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><p><a href="https://www.amxmodx.org/api/">AMX MOD X官方API文档</a></p>
]]></content>
      <categories>
        <category>游戏</category>
        <category>CS</category>
      </categories>
      <tags>
        <tag>游戏</tag>
        <tag>个人爱好</tag>
        <tag>CS-BTE</tag>
        <tag>CSOL单机版</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo博客更换主题</title>
    <url>/2021/02/11/Hexo%E5%8D%9A%E5%AE%A2%E6%9B%B4%E6%8D%A2%E4%B8%BB%E9%A2%98/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在继续往下读这篇文章之前，你应该确保自己已经可以在本地预览Hexo的效果了，如果还不行的话，可以读一下我之前写的文章。</p>
<p>本文将在上一篇文章的基础上，为Hexo更换一个主题，就以Next主题为例子，同时也会讲讲安装Next主题时可能遇到的一些问题。</p>
<h1 id="选一个自己喜欢的主题"><a href="#选一个自己喜欢的主题" class="headerlink" title="选一个自己喜欢的主题"></a>选一个自己喜欢的主题</h1><p>安装完Hexo并第一次跑起来后，你应该会看到这样的界面。</p>
<p><img src="hexo-default.png"></p>
<p>这时Hexo的默认主题Landscape，实际上Hexo社区非常热闹，目前有很多的主题可供选择了，你可以去Hexo官网逛逛，传送门<a href="https://hexo.io/themes/">Hexo官方主题推介</a>。</p>
<p>这里我就以Next主题为例吧，毕竟我自己的博客也是用Next主题的。下面给出Next主题的Github仓库，你可以看看作者的说明，传送门<a href="https://github.com/iissnan/hexo-theme-next">Next主题仓库</a>。</p>
<h1 id="下载安装主题"><a href="#下载安装主题" class="headerlink" title="下载安装主题"></a>下载安装主题</h1><p>在之前使用hexo init命令生成项目后，你应该会发现其中有个目录名称叫themes，没错，这个目录就是用来保存当前这个项目可用的所有的hexo主题，每个主题一个单独的目录，比如下载了next主题，那么它就保存在themes/next中。</p>
<p>使用<code>git clone</code>将next主题下载到你的themes/next目录中，比如当前在项目根目录下，可以用下面的指令来下载主题。</p>
<p><img src="download-next.png" alt="download-next"></p>
<p><code>git clone git@github.com:iissnan/hexo-theme-next.git themes/next</code></p>
<p>随后切换目录到next目录下，安装js依赖，即npm install。</p>
<h1 id="切换主题"><a href="#切换主题" class="headerlink" title="切换主题"></a>切换主题</h1><p>安装完主题后，并没有直接生效，需要在hexo项目根目录下的_config.yml，即全局配置文件中进行切换。</p>
<p><img src="switch-theme.png" alt="switch-theme"></p>
<p>在其中找到theme项，将landscape修改为next，保存退出。</p>
<p>此时你就可以在本地预览next主题的效果了，切换回hexo项目根目录，使用hexo generate和hexo server就可以本地运行，可以简写为hexo g &amp;&amp; hexo s。</p>
<p>启动后，访问localhost:4000，好像不对啊，怎么显示这一串玩意。</p>
<p><img src="error.png" alt="error"></p>
<h1 id="解决错误"><a href="#解决错误" class="headerlink" title="解决错误"></a>解决错误</h1><p>实际上面的报错是因为hexo在5.0之后把一个渲染插件swig给删除了，需要我们自己手动安装。</p>
<p>在hexo项目根目录使用下列指令进行安装。</p>
<p><code>npm install hexo-renderer-swig --save</code></p>
<p>再次hexo g &amp;&amp; hexo s，就可以看到效果了。</p>
<p><img src="next-theme.png" alt="next-theme"></p>
<h1 id="后文"><a href="#后文" class="headerlink" title="后文"></a>后文</h1><p>到这里位置，hexo主题切换就完成了，但你可能还觉得不够好，因为页面默认是英文的，好像点击其中的超链接还会失效，这些都是因为没有进行详细的配置，下次来讲讲next主题的配置和hexo本身的配置，让你对博客页面进行个性定制。</p>
<h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><p><a href="https://theme-next.js.org/docs/getting-started/">Next主题起步指南</a></p>
<p><a href="https://blog.csdn.net/qq_41170983/article/details/109381893">hexo主题next访问报错</a></p>
]]></content>
      <categories>
        <category>Hexo博客系列</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>PostgreSQL使用fdw实现跨库查询</title>
    <url>/2021/08/29/PostgreSQL%E4%BD%BF%E7%94%A8fdw%E5%AE%9E%E7%8E%B0%E8%B7%A8%E5%BA%93%E6%9F%A5%E8%AF%A2/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>PostgreSQL如果想要进行跨库查询，需要使用一个叫做fdw的插件，使用pgsql的命令即可创建，简单实用。</p>
<h1 id="实验准备"><a href="#实验准备" class="headerlink" title="实验准备"></a>实验准备</h1><p>除了插件本身如何安装、配置，我们当然还需要准备跨库的数据，比如这个例子中，假设有这样的表结构，user是用户的基本信息，包括主键id、名字以及身份证号；user_ticket_info表是用户持有的票据信息，id的含义与user表的id是一致的，ticket_type为票据类型，remaining_number为票的余量。</p>
<p><img src="image-20210829201850361.png" alt="image-20210829201850361"></p>
<p>为了方便，我们要可以每张票插入几条数据，方便之后join查询。</p>
<p><img src="image-20210829203228698.png" alt="image-20210829203228698"></p>
<p><img src="image-20210829203414644.png" alt="image-20210829203414644"></p>
<p>假设user在数据库demo_db1中，而user_ticket_info在demo_db2中，我们无法直接使用join语法去关联查询，那么接下来就需要介绍fdw的使用了。</p>
<h1 id="fdw安装与使用"><a href="#fdw安装与使用" class="headerlink" title="fdw安装与使用"></a>fdw安装与使用</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>fdw全程是foreign-data wrapper，PostgreSQL官方提供了一个插件名为postgres_fdw，专门用于访问其他pgsql数据库的数据，这里的其他是相对于当前数据库的，也就是说也可以访问其他主机上的数据库。相比较于传统的pgsql插件dblink，postgres_fdw使我们可以通过标准的sql来使用其他库的数据，可以说相当实用。</p>
<h2 id="创建extension"><a href="#创建extension" class="headerlink" title="创建extension"></a>创建extension</h2><p>首先使用下列命令在demo_db1数据库中创建fdw模块。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> extension postgres_fdw</span><br></pre></td></tr></table></figure>

<h2 id="创建外部数据库"><a href="#创建外部数据库" class="headerlink" title="创建外部数据库"></a>创建外部数据库</h2><p>当前我们使用的是demo_db1这个数据库，我们想使用的表在demo_db2这个数据库中，虽然他们都是在localhost这台主机上，但要使用fdw来进行操作，就得先在demo_db1这边创建一个foreign_server，代表一个外部pgsql服务器。</p>
<p>使用以下命令来创建一个foreign_server。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> SERVER server_name [ TYPE <span class="string">&#x27;server_type&#x27;</span> ] [ VERSION <span class="string">&#x27;server_version&#x27;</span> ]</span><br><span class="line">    <span class="keyword">FOREIGN</span> DATA WRAPPER fdw_name</span><br><span class="line">    [ OPTIONS ( option <span class="string">&#x27;value&#x27;</span> [, ... ] ) ]</span><br></pre></td></tr></table></figure>

<p>这里解释以下每个参数的作用。</p>
<ol>
<li>server_name是你添加的外部服务器名称，具体取什么名并不重要，只是作为当前数据库中使用的一个别名。</li>
<li>server_type，server的类型，可不填。</li>
<li>server_version，server的版本，可不填。</li>
<li>fdw_name，fdw的名称，我们这里使用的是postgres_fdw，那么填postgres_fdw即可，不需要填其他的。</li>
<li>option，选项，一般用来填外部数据库的host地址、数据库名称、端口号。</li>
</ol>
<p>根据上述命令，我们根据需要写出自己的语句。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> server demo_db2 <span class="keyword">foreign</span> data wrapper postgres_fdw options (host <span class="string">&#x27;localhost&#x27;</span>, dbname <span class="string">&#x27;demo_db2&#x27;</span>, port <span class="string">&#x27;5432&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>此时可以用图形工具来看下demo_db1的数据库信息，应该能发现它多了个foreign data wrapper，其内部还包含了个外部数据库demo_db2（我这里使用的是intellij idea自带的数据库管理工具，如果你不用它，也可以尝试一下pgadmin，专门用于PostgreSQL数据库的图形化工具，个人觉得挺好用）。</p>
<p><img src="image-20210829211510547.png" alt="image-20210829211510547"></p>
<h2 id="创建用户映射"><a href="#创建用户映射" class="headerlink" title="创建用户映射"></a>创建用户映射</h2><p>这里的用户映射指的是在demo_db1这边添加的配置，一般是用户名和密码，专门用于连接外部数据库，我们可以创建多个外部数据库，也可以创建多个用户映射专门用于访问每个数据库，它的命令如下。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">CREATE USER MAPPING FOR &#123; user_name | USER | CURRENT_USER | PUBLIC &#125;</span><br><span class="line">    SERVER server_name</span><br><span class="line">    [ OPTIONS ( option <span class="string">&#x27;value&#x27;</span> [ , ... ] ) ]</span><br></pre></td></tr></table></figure>

<p>照样来介绍下各个参数的作用。</p>
<ol>
<li>user_name，当前数据库上存在的一个用户，用于映射到外部数据库的某个用户。也可以使用USER或者CURRENT_USER来指代当前操作的用户；而如果你使用的是PUBLIC，则相当于创建一个公共映射，如果你没有创建其他的用户映射，那么默认就会使用它。</li>
<li>server_name，输入一个外部数据库名称即可，比如我们刚才创建的那个demo_db2。</li>
<li>options，一般用于指定外部数据库的用户名和密码。</li>
</ol>
<p>转换为我们当前这个案例的场景，写出以下sql。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">user</span> mapping <span class="keyword">for</span> <span class="built_in">CURRENT_USER</span> server demo_db2 options (<span class="keyword">user</span> <span class="string">&#x27;postgres&#x27;</span>, password <span class="string">&#x27;123456&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>这里你也可以将CURRENT_USER改成特定的用户，但options是必须填的，填的是demo_db2的用户，即外部数据库的用户。</p>
<h2 id="在当前数据库创建一个schema"><a href="#在当前数据库创建一个schema" class="headerlink" title="在当前数据库创建一个schema"></a>在当前数据库创建一个schema</h2><p>为什么要创建一个schema？说白了，实际上就是将外部数据库的schema定义信息（即各个表的定义，不包括数据）全部导入到当前数据库里，schema相当于是个“容器”，有了这个schema，我们就能像操作当前库的数据一样，操纵外部数据库。</p>
<p>这里就随意创建一个temp_schema了，你也可以根据自己的需要来决定如何定义这个schema。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> schema temp_schema;</span><br></pre></td></tr></table></figure>

<h2 id="导入外部数据库的schema信息"><a href="#导入外部数据库的schema信息" class="headerlink" title="导入外部数据库的schema信息"></a>导入外部数据库的schema信息</h2><p>此时我们只需要将demo_db2中用来存储数据的那个schema一股脑导入到temp_schema上就可以了。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">IMPORT <span class="keyword">FOREIGN</span> SCHEMA remote_schema</span><br><span class="line">    [ &#123; LIMIT TO | EXCEPT &#125; ( table_name [, ...] ) ]</span><br><span class="line">    <span class="keyword">FROM</span> SERVER server_name</span><br><span class="line">    <span class="keyword">INTO</span> local_schema</span><br><span class="line">    [ OPTIONS ( option <span class="string">&#x27;value&#x27;</span> [, ... ] ) ]</span><br></pre></td></tr></table></figure>

<p>按惯例介绍以下各个参数的作用。</p>
<ol>
<li>remote_schema，外部数据库的schema名称。</li>
<li>limit to (…)，只导入某几个表，圆括号内是需要导入的表名，比如我只导入user_ticket_info，则是limit to (user_ticket_info)</li>
<li>except (…)，不导入哪些表，圆括号内是不导入的表明，用法同limit to一致。</li>
<li>server_name，即外部数据库名。</li>
<li>local_schema，即我们刚才创建的用于存放外部schema信息的那个新schema名。</li>
<li>options，其实我也不太清楚这条命令里，options具体能干啥，但一般来说不填即可，PostgreSQL官方文档上的说法是：“specific to each foreign data wrapper”。</li>
</ol>
<p>写出本案例中的import命令。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">import <span class="keyword">foreign</span> schema public <span class="keyword">from</span> server demo_db2 <span class="keyword">into</span> temp_schema</span><br></pre></td></tr></table></figure>

<h2 id="查看并使用外部数据"><a href="#查看并使用外部数据" class="headerlink" title="查看并使用外部数据"></a>查看并使用外部数据</h2><p>上一步导入了foreign schema后，我们就可以像使用本地schema一样访问外部的schema了。</p>
<p><img src="image-20210829213646559.png" alt="image-20210829213646559"></p>
<p>尝试使用join语法关联查询，注意需要区分schema。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> u.id, u.name, u.id_card_no, uti.ticket_type, uti.remaining_number <span class="keyword">from</span> public.user u</span><br><span class="line">    <span class="keyword">left</span> <span class="keyword">join</span> temp_schema.user_ticket_info uti <span class="keyword">on</span> uti.id<span class="operator">=</span>u.id;</span><br></pre></td></tr></table></figure>

<p>查询结果如下，实验成功。</p>
<p><img src="image-20210829213920015.png" alt="image-20210829213920015"></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>使用fdw可以让我们像使用本地数据那样使用外部数据，并且postgres_fdw是PostgreSQL官方提供的插件，并不需要使用其他分库分表的中间件，快捷、高效，在跨库查询的需求相对简单来说，是一个很不错的选择。</p>
]]></content>
      <categories>
        <category>数据库</category>
        <category>PostgreSQL</category>
      </categories>
      <tags>
        <tag>PostgreSQL</tag>
        <tag>数据库</tag>
        <tag>跨库查询</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringApplicationEvent使用案例</title>
    <url>/2021/09/03/SpringApplicationEvent%E4%BD%BF%E7%94%A8%E6%A1%88%E4%BE%8B/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Spring提供了两个核心类ApplicationListener和ApplicationEvent，用以支持事务处理，每当一种ApplicationEvent发布到ApplicationContext中，一种对应的ApplicationListener就会被触发调用（如果确实定义了的话），这是典型的观察者设计模式的应用。</p>
<p>这里用一张图来简单概括一下Spring事件机制的作用。</p>
<p><img src="image-20210902102408150.png" alt="image-20210902102408150"></p>
<p>若不使用事件机制，代码A是直接引用代码B的，两者存在一个强耦合，但如果引入Spring事件机制，则代码A发布事件给ApplicationContext，再由ApplicationContext去通知所有该事件的ApplicationListener，由它去调用代码B。</p>
<p>关于使用Spring的事件处理功能到底有啥好处，这里引用一个Stackoverflow上的回答，我觉得在一定程度上解答了这个问题。</p>
<blockquote>
<p>One of the advantages to using Spring’s event publishing (observer pattern - <a href="http://en.wikipedia.org/wiki/Observer_pattern">http://en.wikipedia.org/wiki/Observer_pattern</a>) is that the components are loosely coupled - there is no direct coupling between the publisher and the subscriber. Sure, they both have a dependency on the Spring Event API, but not on each other. This makes it possible to extend the application by adding/removing subscribers without affecting other subscribers (assuming that your subscribers don’t depend on each other).</p>
</blockquote>
<p>如果你对原回答感兴趣，可以参考本文末的参考文章一栏。</p>
<h1 id="定义事件"><a href="#定义事件" class="headerlink" title="定义事件"></a>定义事件</h1><p>即ApplicationEvent，在实际使用中，我们都需要自己定义一个ApplicationEvent的子类，这里给出一个简单的例子，假设用户注册后，我们要给用户发送一封电子邮件。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RegisterEvent</span> <span class="keyword">extends</span> <span class="title">ApplicationEvent</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> String username, email;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RegisterEvent</span><span class="params">(Object source, String username, String email)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(source);</span><br><span class="line">        <span class="keyword">this</span>.username = username;</span><br><span class="line">        <span class="keyword">this</span>.email = email;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们定义一个RegisterEvent，继承自ApplicationEvent，父类默认就有一个构造方法，传入一个Object source，这个source是啥？来看看源码注释。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Create a new &#123;<span class="doctag">@code</span> ApplicationEvent&#125;.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> source the object on which the event initially occurred or with</span></span><br><span class="line"><span class="comment"> * which the event is associated (never &#123;<span class="doctag">@code</span> null&#125;)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ApplicationEvent</span><span class="params">(Object source)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">super</span>(source);</span><br><span class="line">   <span class="keyword">this</span>.timestamp = System.currentTimeMillis();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个source，实际上就是事件触发时所在的对象，所以一般来说，像下面这样构造就好了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> RegisterEvent(<span class="keyword">this</span>, username, email);</span><br></pre></td></tr></table></figure>

<h2 id="Spring生命周期内置事件"><a href="#Spring生命周期内置事件" class="headerlink" title="Spring生命周期内置事件"></a>Spring生命周期内置事件</h2><p>Spring框架中，ApplicationContext的生命周期也会伴随着一些它自带的事件触发。</p>
<table>
<thead>
<tr>
<th align="left">Event</th>
<th align="left">Explanation</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>ContextRefreshedEvent</code></td>
<td align="left">ApplicationContext初始化、刷新时会触发该事件，即ApplicationContext的refresh()方法被调用时</td>
</tr>
<tr>
<td align="left">`ContextStartedEvent</td>
<td align="left">通过start()方法启动ApplicationContext时会触发该事件，比如先通过stop()方法停止了ApplicationContext，再通过start()方法启动，就能触发这个事件</td>
</tr>
<tr>
<td align="left"><code>ContextStoppedEvent</code></td>
<td align="left">通过stop()方法停止ApplicationContext时会触发该事件，停止后，可以通过start()方法来重新启动ApplicationContext</td>
</tr>
<tr>
<td align="left"><code>ContextClosedEvent</code></td>
<td align="left">通过close()方法关闭ApplicationContext时会触发该事件，或者通过JVM关闭钩子，也可以触发该事件，被关闭后，ApplicationContext就不可能再被刷新或者启动了</td>
</tr>
<tr>
<td align="left"><code>RequestHandledEvent</code></td>
<td align="left">当一个http请求被处理后，会触发这个事件，只有web应用下才会触发这个事件，即通过DispatcherServlet处理请求的应用</td>
</tr>
<tr>
<td align="left"><code>ServletRequestHandledEvent</code></td>
<td align="left">RequestHandleEvent的子类，多了一些Servlet请求的信息</td>
</tr>
</tbody></table>
<h1 id="触发事件"><a href="#触发事件" class="headerlink" title="触发事件"></a>触发事件</h1><h2 id="使用ApplicationEventPublisher发布事件"><a href="#使用ApplicationEventPublisher发布事件" class="headerlink" title="使用ApplicationEventPublisher发布事件"></a>使用ApplicationEventPublisher发布事件</h2><p>我们可以通过ApplicationEventPublisher的publishEvent方法来发布一个事件，一般来说，我们可以再需要发布事件的类上实现ApplicationEventPublisherAware接口，如此一来就有一个setApplicationEventPublisher方法，可以让我们将ApplicationEventPublisher，然后将这个类注册为Spring的bean即可。</p>
<p>转换为代码，假设现在我们需要在RegisterService内发布RegisterEvent事件，那只需要让RegisterService实现ApplicationEventPublisherAware接口，然后将RegisterService注册为bean（@Service、@Component等）即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RegisterService</span> <span class="keyword">implements</span> <span class="title">ApplicationEventPublisherAware</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ApplicationEventPublisher publisher;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setApplicationEventPublisher</span><span class="params">(ApplicationEventPublisher applicationEventPublisher)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.publisher = applicationEventPublisher;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(String username, String email)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// do something to register a user</span></span><br><span class="line">        <span class="comment">// ......</span></span><br><span class="line">        publisher.publishEvent(<span class="keyword">new</span> RegisterEvent(<span class="keyword">this</span>, username, email));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="使用ApplicationContext发布事件"><a href="#使用ApplicationContext发布事件" class="headerlink" title="使用ApplicationContext发布事件"></a>使用ApplicationContext发布事件</h2><p>虽然我们可以通过上面的方式注入一个ApplicationEventPublisher来发布事件，但其实还有一种更方便、高效的方式，我们来看看ApplicationContext的接口定义。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ApplicationContext</span> <span class="keyword">extends</span> <span class="title">EnvironmentCapable</span>, <span class="title">ListableBeanFactory</span>, <span class="title">HierarchicalBeanFactory</span>,</span></span><br><span class="line"><span class="class">      <span class="title">MessageSource</span>, <span class="title">ApplicationEventPublisher</span>, <span class="title">ResourcePatternResolver</span></span></span><br></pre></td></tr></table></figure>

<p>可以看到ApplicationContext自身就实现了ApplicationEventPublisher，也就是说，ApplicationContext自身就可以用来发布事件。</p>
<p>改造一下上面的RegisterService，得到下面的代码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RegisterService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ApplicationContext applicationContext;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(String username, String email)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// do something to register a user</span></span><br><span class="line">        <span class="comment">// ......</span></span><br><span class="line">        applicationContext.publishEvent(<span class="keyword">new</span> RegisterEvent(<span class="keyword">this</span>, username, email));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="监听事件"><a href="#监听事件" class="headerlink" title="监听事件"></a>监听事件</h1><h2 id="实现ApplicationListener接口"><a href="#实现ApplicationListener接口" class="headerlink" title="实现ApplicationListener接口"></a>实现ApplicationListener接口</h2><p>定义一个ApplicationListener接口的实现类，并注册为bean，即可监听对应的事件。比如下面的例子。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EmailRegisterEventListener</span> <span class="keyword">implements</span> <span class="title">ApplicationListener</span>&lt;<span class="title">RegisterEvent</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onApplicationEvent</span><span class="params">(RegisterEvent event)</span> </span>&#123;</span><br><span class="line">        String username = event.getUsername(), email = event.getEmail();</span><br><span class="line">        System.out.println(String.format(<span class="string">&quot;sending email for user %s to mailbox %s&quot;</span>, username, email));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="注册多个ApplicationListener"><a href="#注册多个ApplicationListener" class="headerlink" title="注册多个ApplicationListener"></a>注册多个ApplicationListener</h2><p>针对一种ApplicationEvent，可以定义多个不同的ApplicationListener，针对上面这个例子，假设还需要为用户发送一条短信，那么可以再定义一个MobileRegisterEventListener。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MobileRegisterEventListener</span> <span class="keyword">implements</span> <span class="title">ApplicationListener</span>&lt;<span class="title">RegisterEvent</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onApplicationEvent</span><span class="params">(RegisterEvent event)</span> </span>&#123;</span><br><span class="line">        String username = event.getUsername();</span><br><span class="line">        System.out.println(<span class="string">&quot;sending text message for user &quot;</span> + username);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如此一来，就有两个ApplicationListener用于监听RegisterEvent了。写一个单元测试，来发布一个事件。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EventDemoApplicationTests</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RegisterService registerService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">testEvent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        registerService.register(<span class="string">&quot;zenox&quot;</span>, <span class="string">&quot;test@mail.com&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>查看结果如下，可见发布一个事件，被两个对应的ApplicationListener监听到了。</p>
<p><img src="image-20210902184310709.png" alt="image-20210902184310709"></p>
<h2 id="事务特性"><a href="#事务特性" class="headerlink" title="事务特性"></a>事务特性</h2><p>以上所讲的ApplicationListener监听到了事件后，实际上都是<strong>同步执行的</strong>，也就是说当publishEvent方法被调用后，会一直阻塞到所有ApplicationListener都执行完成，所以，这种同步执行的方式，其对事务的支持也是和普通方法一样的，如果监听到事件并准备执行时，当前是在一个事务中的，那么会加入到当前事务中。</p>
<p>至于如何定义异步的监听器，请看后续小节。</p>
<h2 id="基于注解的事务监听"><a href="#基于注解的事务监听" class="headerlink" title="基于注解的事务监听"></a>基于注解的事务监听</h2><p>除了直接实现ApplicationListener接口，我们还可以使用注解来定义ApplicationListener，这种方式更加简单、灵活。</p>
<p>直接将上面两个例子中的ApplicationListener整合到一起，并使用注解方式实现。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EventListener</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">listenThenSendEmail</span><span class="params">(RegisterEvent event)</span></span>&#123;</span><br><span class="line">    String username = event.getUsername(), email = event.getEmail();</span><br><span class="line">    System.out.println(String.format(<span class="string">&quot;sending email for user %s to mailbox %s&quot;</span>, username, email));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@EventListener</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">listenThenSendTextMessage</span><span class="params">(RegisterEvent event)</span></span>&#123;</span><br><span class="line">    String username = event.getUsername();</span><br><span class="line">    System.out.println(<span class="string">&quot;sending text message for user &quot;</span> + username);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，只需要用@EventListener来标注一下方法，方法参数需要给定为对应的事件类型，如此一来，当对应的事件被发布时，该方法就会被同步执行。</p>
<h2 id="监听多事件"><a href="#监听多事件" class="headerlink" title="监听多事件"></a>监听多事件</h2><p>使用注解监听事件，还可以指定一个方法监听多个不同的事件。只需要在EventListener注解上添加多个事件的class即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EventListener(&#123;RegisterEvent.class, BatchRegisterEvent.class&#125;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">listenMyEvents</span><span class="params">()</span></span>&#123;</span><br><span class="line">    System.out.println(String.format(<span class="string">&quot;register events triggered&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但需要注意的是，注册了多事件的方法，一定不能有参数。</p>
<h2 id="链式事件"><a href="#链式事件" class="headerlink" title="链式事件"></a>链式事件</h2><p>如果你希望当前事件处理完后，立刻触发另一个事件，新触发的事件可以被直接监听并处理，Spring也支持。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EventListener</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ListUpdateEvent <span class="title">handleBlockedListEvent</span><span class="params">(BlockedListEvent event)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// notify appropriate parties via notificationAddress and</span></span><br><span class="line">    <span class="comment">// then publish a ListUpdateEvent...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将方法返回值设为一个事件即可，在方法的最后，返回一个新的事件。</p>
<p>如果你想要触发多个事件，那么可以返回一个Collection或者数组。</p>
<h2 id="异步事件"><a href="#异步事件" class="headerlink" title="异步事件"></a>异步事件</h2><p>如上面所述，ApplicationListener默认是同步处理事件的，即publishEvent方法会一直阻塞，直到ApplicationListener执行完成。</p>
<p>如果想要让它异步执行，只需要在方法上加上@Async即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EventListener</span></span><br><span class="line"><span class="meta">@Async</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processBlockedListEvent</span><span class="params">(BlockedListEvent event)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// BlockedListEvent is processed in a separate thread</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是异步事件处理有两点限制。</p>
<ol>
<li>异步方法抛出异常时，该异常并不能被publishEvent捕获，具体可以参照@Async注解的异常处理。</li>
<li>异步事件不能像上述的同步方法一样，通过返回一个ApplicationEvent来链式触发事件，而必须得注入一个ApplicationEventPublisher来发布事件。</li>
</ol>
<h2 id="Listener排序"><a href="#Listener排序" class="headerlink" title="Listener排序"></a>Listener排序</h2><p>使用Order注解，即可对监听同一事件的Listener排序。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EventListener</span></span><br><span class="line"><span class="meta">@Order(42)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processBlockedListEvent</span><span class="params">(BlockedListEvent event)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// notify appropriate parties via notificationAddress...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><p><a href="https://stackoverflow.com/questions/5239448/what-are-the-advantages-of-using-spring-application-event-publishing">What are the advantages of using Spring application event publishing?</a></p>
<p><a href="https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#context-functionality-events">Spring官方文档–context-functionality-events</a></p>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>ApplicationEvent</tag>
        <tag>Java异步事件</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringCloudStream入门及案例</title>
    <url>/2021/07/11/SpringCloudStream%E5%85%A5%E9%97%A8%E5%8F%8A%E6%A1%88%E4%BE%8B/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在微服务架构流行的今天，消息队列的应用显得尤为重要，然而对于一个Java或者说一个Spring项目来说，不同的消息队列需要导入不同的driver依赖，这种情况下，就产生了一个痛点，即项目极有可能深度与某个特定的消息队列绑定，而通过本文所述的这项技术Spring Cloud Stream，可以将消息队列driver的实现与应用代码分离，即开发者不需要再写带有“mq特色”的代码了。</p>
<p>过去，我们可以通过Spring Integration来集成各种企业级别应用的外部系统，比如数据库、消息队列，随着Spring Boot的不断壮大和流行，官方将Spring Integration与Spring Boot整合到了一块，形成了一个新的项目–Spring Cloud Stream。</p>
<h1 id="定义消费者程序"><a href="#定义消费者程序" class="headerlink" title="定义消费者程序"></a>定义消费者程序</h1><p>以下的案例根据Spring官方文档编写。</p>
<h2 id="创建SpringBoot项目"><a href="#创建SpringBoot项目" class="headerlink" title="创建SpringBoot项目"></a>创建SpringBoot项目</h2><p>由于Spring Cloud Stream项目是基于Spring Boot的，那么自然可以使用Spring Initializr进行快速构建，这个案例需要以下的依赖，这里用到的消息队列实现是RabbitMQ，当然如果你用的是Kafka、RocketMQ等，SpringCloudStream也支持，其他消息队列具体如何集成、配置都可以从<a href="https://docs.spring.io/spring-cloud-stream/docs/3.1.3/reference/html/index.html">官方文档</a>上找到。</p>
<ul>
<li>Spring-RabbitMQ集成</li>
<li>Spring Cloud Stream</li>
</ul>
<p><img src="image-20210729200443316.png" alt="image-20210729200443316"></p>
<h2 id="定义消息实体"><a href="#定义消息实体" class="headerlink" title="定义消息实体"></a>定义消息实体</h2><p>在这个项目中，我们一定是希望将Java对象作为消息在微服务之间传递，假设要传递的对象就是Person类，包含他的名字、年龄等信息。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(Integer age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="定义消费者"><a href="#定义消费者" class="headerlink" title="定义消费者"></a>定义消费者</h2><p>由于相对比较复杂，这里暂时先不讨论生产者是如何定义的，而是先说说怎么定义消费者。</p>
<p>创建一个Configuration类（或者用Component、Service等注解都是可以的），然后其中定义一个Consumer的Bean，其职责就是用来接收并消费Person消息，如下所示。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MessageConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Consumer&lt;Person&gt; <span class="title">consumerPerson</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> person -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;接收到Person信息：&quot;</span> + person.getName() + <span class="string">&quot;,&quot;</span> + <span class="string">&quot;年龄&quot;</span> + person.getAge());</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到这边使用了java.util.function.Consumer，使用过java 8特性函数式编程的朋友应该不陌生，这里不展开介绍java 8的函数式编程和lamda表达式，如果有需要的话，这里推介一个我比较喜欢的知乎博主的文章 <a href="https://www.zhihu.com/question/37872003/answer/1009015660">在Java代码中写Lambda表达式是种怎样的体验？</a></p>
<p>这里需要说一下，SpringCloudStream目前的最新版本3.1.3支持两种编程模式，第一种就是我上面的这种，即函数式编程，也是官方主推的使用方式；而另一种基于注解的使用方式，虽然3.1.3版本也支持，但按照官方说法，在不久的将来也许就要废弃了，所以本文后续使用的都是Spring官方主推的函数式编程。</p>
<h2 id="安装一个用于测试的消息队列"><a href="#安装一个用于测试的消息队列" class="headerlink" title="安装一个用于测试的消息队列"></a>安装一个用于测试的消息队列</h2><p>定义好消费者代码后，实际上这个应用程序就已经具备了接收Person对象的能力，但还有两个问题，从<strong>哪里</strong>消费？<strong>如何</strong>消费？</p>
<p>先回答第一个问题，由于我们导入的是RabbitMQ与Spring的集成依赖，如果你不进行任何配置，在SpringBoot程序启动时自动尝试去连接localhost的5672端口，即RabbitMQ的默认端口，连接上后，框架自己会使用默认的配置创建一个exchange和一个对应的queue。</p>
<p>第二个问题，如何消费，正常情况下，我们一般会有一个对应的生产者程序，但这个例子里，我们只是演示如何使用Consumer端，那么可以直接使用RabbitMQ的管理端来发送测试消息，消费者会自动从消息队列中取出消息（一般来说就是json字符串），并自动转换为java对象。</p>
<p>了解消费者的工作模式后，就来安装一个RabbitMQ吧，我这里使用的是Docker镜像，可以参考下面的Docker指令，创建的RabbitMQ容器默认向外暴露5672和15672两个端口，即可以直接通过浏览器访问RabbitMQ管理端。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">拉取镜像rabbitmq:management，自带管理界面</span></span><br><span class="line">docker pull rabbitmq:management</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">运行镜像，这里简单配置了端口映射，账户名密码使用默认的guest guest</span></span><br><span class="line">docker run --name rabbitmq-test -p 15672:15672 -p 5672:5672 rabbitmq:management</span><br></pre></td></tr></table></figure>

<p>运行完成后，可以访问localhost:15672来查看是否安装成功。</p>
<p>当然如果你改一下Spring连接RabbitMQ的配置，通过配置文件application.properties或者application.yml修改即可。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="string">localhost</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">5672</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">guest</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">guest</span></span><br></pre></td></tr></table></figure>

<h2 id="发送Person消息进行测试"><a href="#发送Person消息进行测试" class="headerlink" title="发送Person消息进行测试"></a>发送Person消息进行测试</h2><p>将程序运行起来，可以看到控制台输出了几句话，一般是这样的。</p>
<p><img src="image-20210729205413063.png" alt="image-20210729205413063"></p>
<p>如果有上面这几句输出，一般说明程序成功连接上rabbitMQ并且根据consumer的定义自行创建了exchange和queue。</p>
<p>前往rabbitMQ管理端，找到对应的queue，在payload内填入json数据，包括Person的两个字段，点击publish message。</p>
<p><img src="image-20210729205815454.png" alt="image-20210729205815454"></p>
<p>查看应用程序的控制台，可以发现消费者已经将刚才发送的消息打印了出来。</p>
<p><img src="image-20210729205927900.png" alt="image-20210729205927900"></p>
<p>当然这仅仅是一个简单的消费者使用案例，如何定义生产者？以及如何控制SpringCloudStream操作RabbitMQ等，这都需要更多的配置，在本文后续会讲到。</p>
<h1 id="定义生产者程序"><a href="#定义生产者程序" class="headerlink" title="定义生产者程序"></a>定义生产者程序</h1><p>在上面的简单示例中，我们看了SpringCloudStream是如何定义消费者的，但一个完整的程序当然少不了生产者端，但相较于生产者程序，要稍微复杂一些。</p>
<h2 id="Supplier类型的生产者"><a href="#Supplier类型的生产者" class="headerlink" title="Supplier类型的生产者"></a>Supplier类型的生产者</h2><p>既然生产者是通过定义一个java.util.function.Consumer来实现的，如果你了解Java函数式的使用，可能会猜想，生产者程序是不是通过java.util.function.Supplier来实现呢？可以这么说，但不完全对，这只是定义生产者程序其中一种方式。</p>
<p>在上面消费者的例子上，将原先的Consumer修改一下，改为Supplier，为Person实体声明一个生产者的Bean。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function">Supplier&lt;Person&gt; <span class="title">producePerson</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> () -&gt; <span class="keyword">new</span> Person(<span class="string">&quot;zenox&quot;</span>, <span class="number">24</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码非常简单，仅仅是声明了一个Supplier类型的Bean，那么它是如何生产Person类型的消息的呢？事实上，Supplier类型会定期（默认一秒钟一次）自动生产对应的消息，然后发送到消息队列。</p>
<p>这大概不是你想要的答案吧？没错，一开始我也觉得怪，但这种Supplier的方式是官方文档上介绍的。</p>
<p>一般情况下，我们使用消息队列的场景可能是这样的，一个web请求过来了，触发了某些需要异步处理的事务，于是产生一条消息，发送至消息队列，消费者端监听到这条消息后，才开始执行异步这个事务。</p>
<p>好在Spring官方也提供了这种支持。</p>
<h2 id="使用StreamBridge来充当生产者"><a href="#使用StreamBridge来充当生产者" class="headerlink" title="使用StreamBridge来充当生产者"></a>使用StreamBridge来充当生产者</h2><p>StreamBridge可以理解为一个管道，它提供了一个send方法，可以将消息发送至某个消息队列，我们可以使用它来实现生产者的功能。</p>
<h3 id="send方法解析"><a href="#send方法解析" class="headerlink" title="send方法解析"></a>send方法解析</h3><p>我们先来看一看StreamBridge中关于send的源码注释。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Sends &#x27;data&#x27; to an output binding specified by &#x27;bindingName&#x27; argument while</span></span><br><span class="line"><span class="comment"> * using default content type to deal with output type conversion (if necessary).</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> bindingName the name of the output binding</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> data the data to send</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> true if data was sent successfully, otherwise false or throws an exception.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">send</span><span class="params">(String bindingName, Object data)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">this</span>.send(bindingName, data, MimeTypeUtils.APPLICATION_JSON);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注释的大意基本是这样的：将data，也就是我们的消息对象，以默认的JSON格式发送到<strong>“binding”</strong>那边，如果发送成功，会返回true，如果发送失败，则返回false或者抛出异常。</p>
<p>这里需要了解binding是个啥？这里也不卖关子了，binding可以理解为一个绑定关系，绑定的双方实际上就是消费者方法和消息队列，这里可能让你比较迷惑，为什么讲生产者，又扯起消费者队列了？但你可以这么想想，StreamBridge就是个管道，我们通过这个管道，将消息或数据发送至消费者队列，binding即目标消息队列，这样是不是就好理解了？</p>
<p>那这边binding该怎么定义？</p>
<h3 id="配置binding"><a href="#配置binding" class="headerlink" title="配置binding"></a>配置binding</h3><p>在原有的消费者程序基础上，配置application.yml。这里需要注意一下，我们在Consumer程序中定义的那个Consumer方法名为consumePerson。默认情况下，SpringCloudStream会自动为Consumer和Supplier类型的方法生成binding，比如这里的consumePerson即自动生成consumePerson-in-0的binding，而如果是Supplier类型的方法，则生成xxxx-out-0。</p>
<p>我们可以修改默认的binding名，使用spring.cloud.stream.function.defination和spring.cloud.stream.function.bindings即可。</p>
<p>假设，这里，我们希望将原来长长的那一串consumePerson-in-0改的容易理解一些，改成person-receive，可以像下面这样。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">stream:</span></span><br><span class="line">      <span class="attr">function:</span></span><br><span class="line">        <span class="attr">definition:</span> <span class="string">consumePerson</span></span><br><span class="line">        <span class="attr">bindings:</span> </span><br><span class="line">          <span class="attr">consumePerson-in-0:</span> <span class="string">person-receive</span>  </span><br></pre></td></tr></table></figure>

<p>其中spring.cloud.stream.function.defination是消费者方法定义的声明，你所定义的消费者方法必须写在这边，来为它们修改binding。</p>
<p>这个例子中，我们只有一个消费者方法名为consumePerson，我们将其binding名改为person-receive。</p>
<p>那么，binding如何跟queue对应呢？默认情况下，binding名即为queue名，按现在的配置，启动程序后，SpringCloudStream会自动为我们声明一个person-receive的queue。</p>
<p>我们也可以修改这个queue的名称，仍然使用application.yml进行配置即可。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">stream:</span></span><br><span class="line">      <span class="attr">function:</span></span><br><span class="line">        <span class="attr">definition:</span> <span class="string">consumePerson</span></span><br><span class="line">        <span class="attr">bindings:</span></span><br><span class="line">          <span class="attr">consumePerson-in-0:</span> <span class="string">person-receive</span></span><br><span class="line">      <span class="comment"># 新增的配置</span></span><br><span class="line">      <span class="attr">bindings:</span></span><br><span class="line">        <span class="attr">person-receive:</span></span><br><span class="line">          <span class="attr">destination:</span> <span class="string">person-receive-channel</span></span><br></pre></td></tr></table></figure>

<p>如上述配置所示，我们将binding person-receive的目标指向一个叫person-receive-channel的queue，使用的是spring.cloud.stream.bindings.xxx.destination，该配置项可以让我们自行指定binding与queue之间的映射关系。</p>
<p>启动程序，查看RabbitMQ界面，果然发现自动生成的是person-receive-channel，但可以发现，person-receive-channel名称后面还有一串奇怪的字符串，这实际上是<strong>group</strong>，本文后面会讲到。</p>
<p><img src="image-20210808191908850.png" alt="image-20210808191908850"></p>
<h3 id="声明并调用StreamBridge"><a href="#声明并调用StreamBridge" class="headerlink" title="声明并调用StreamBridge"></a>声明并调用StreamBridge</h3><p>既然现在已经了解了binding到底是什么东西，我们就可以比较方便的使用StreamBridge了，参照下面的代码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> StreamBridge streamBridge;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendPerson</span><span class="params">(Person person)</span> </span>&#123;</span><br><span class="line">        streamBridge.send(<span class="string">&quot;person-receive&quot;</span>, person);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以将StreamBridge给注入到需要使用的地方，比如Service层或者Controller层。然后调用send方法，如前文所述，StreamBridge会将Person对象以json格式发送到对应binding的queue上，这个例子中，我们已经配置了，binding为person-receive，binding对应的queue为person-receive-channel。</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>这里为这边的配置做一个小结：spring.cloud.stream.function.defination为我们自己声明的消费者方法名，spring.cloud.stream.function.bindings为方法名到binding的映射（默认情况下，不配置的话，即根据方法名自动生成xxx-in-0这样的binding）；spring.cloud.stream.bindings.xxx.destination为binding到queue的映射（默认情况下，根据binding名自动生成一个对应的queue）。</p>
<p>最后，通过StreamBridge，将Person对象发送到相应的queue内即可。</p>
<h1 id="group概念"><a href="#group概念" class="headerlink" title="group概念"></a>group概念</h1><p>前面的生产者案例中，我们看到了如何声明消费者的binding和queue的对应关系，也发现了SpringCloudStream默认的生成的queue包含了一个奇怪的字符串，实际上这个后缀是该binding所属的group，这是啥？这一节，我们就来了解一下SpringCloudStream的group概念。</p>
<p>对于消费者而言，SpringCloudStream提供了一个group的概念，下面举一个例子来更好的理解。</p>
<p><img src="image-20210808194437896.png" alt="image-20210808194437896"></p>
<p>上述例子中，数据源是HTTP，发送到raw-sensor-data（可以理解为数据处理层），然后raw-sensor-data将其分别发送给两个程序HDFS Write（写入数据库）和Average Calculator（参与计算），假设线上环境中，两个程序为了保证高可用，都是多实例的，HDFS Write有实例1和2，Average Calculator也有实例1和2。那么SpringCloudStream在这种情况下，如何保证多实例不会重复消费数据？这里就要引入group的概念，按照Spring官方的解释，同一个group下的多个相同消费者A、B、C，对于同一个消息info，虽然A、B、C都可以消费这个信息，但由于它们是同一个group，只有其中一个会去消费它。默认情况下，消费的顺序是轮询的，这次是A，下次是B，再下次是C，然后从头开始轮替。</p>
<p>在上图的例子中，将两个HDFS Write的实例的group设为hdfsWrite，将两个Average Calculator的实例的group设为average，如此一来，两个程序都只有其中一个实例会消费消息，避免了消息的重复消费。</p>
<h2 id="配置group"><a href="#配置group" class="headerlink" title="配置group"></a>配置group</h2><p>回到我们自己的例子上来，假设现在我们的程序也有两个实例，此时也需要设置group来防止重复消费，我们可以通过两种配置方式来设置它。</p>
<ol>
<li><p>spring.cloud.stream.default.group</p>
</li>
<li><p>spring.cloud.stream.bindings.xxx.group</p>
</li>
</ol>
<p>第一种方式的配置会被所有consumer共享，即所有的consumer都属于这个group，第二种方式是为指定binding的group，随意使用其中哪种都可以实现我们的目标。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">stream:</span></span><br><span class="line">      <span class="attr">function:</span></span><br><span class="line">        <span class="attr">definition:</span> <span class="string">consumePerson</span></span><br><span class="line">        <span class="attr">bindings:</span></span><br><span class="line">          <span class="attr">consumePerson-in-0:</span> <span class="string">person-receive</span></span><br><span class="line">      <span class="attr">bindings:</span></span><br><span class="line">        <span class="attr">person-receive:</span></span><br><span class="line">          <span class="attr">destination:</span> <span class="string">person-receive-channel</span></span><br><span class="line">          <span class="comment"># 配置group</span></span><br><span class="line">          <span class="attr">group:</span> <span class="string">main</span></span><br></pre></td></tr></table></figure>

<p>启动程序，发现生成的queue名自带了main后缀，无论启动多少个实例，一条消息只会供其中一个消费者消费，而不是每个实例都去消费一遍。</p>
<p><img src="image-20210808200956001.png" alt="image-20210808200956001"></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本文简述了Spring Cloud Stream的作用、使用，但3.0以上的Spring Cloud Stream无论是功能、特性，都远比本文所述的要多得多，比如对单元测试的支持、响应式编程、错误处理机制等，若你还有更多疑问，可以参考<a href="https://spring.io/projects/spring-cloud-stream">Spring Cloud Stream的官方文档</a>。</p>
<h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><p><a href="https://spring.io/projects/spring-cloud-stream">Spring Cloud Stream的官方文档</a></p>
<p><a href="https://www.baeldung.com/spring-cloud-stream">Introduction to Spring Cloud Stream</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/83938579">Spring Cloud系列之Spring Cloud Stream</a></p>
]]></content>
      <categories>
        <category>Spring</category>
        <category>SpringCloudStream</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>SpringCloudStream</tag>
        <tag>rabbitMQ</tag>
        <tag>消息队列</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringValidation使用指南--Controller与Service入参校验</title>
    <url>/2021/03/04/SpringValidation%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97--Controller%E4%B8%8EService%E5%85%A5%E5%8F%82%E6%A0%A1%E9%AA%8C/</url>
    <content><![CDATA[<p>由于近期需要对公司项目中现有的一些Controller和Service方法入参做校验，于是专门去学习了一下HibernateValidator，由于对Spring和Hibernate的校验技术背景不太了解，很多地方简直看的一脸懵，但这两天看了几篇质量极高的博客后，对Spring这一套Validation技术稍微有了点了解，理清了它们之间的关系，最近这几天会慢慢把这篇文章完善起来。</p>
<h1 id="JSR-303、Hibernate-Validator与Spring-Validation之间的关系"><a href="#JSR-303、Hibernate-Validator与Spring-Validation之间的关系" class="headerlink" title="JSR-303、Hibernate Validator与Spring Validation之间的关系"></a>JSR-303、Hibernate Validator与Spring Validation之间的关系</h1><p>做SpingBoot程序时，我们经常需要进行方法参数校验，相信很多人都用过@Valid注解以及@NotNull、@NotEmpty、@Min、@Max这样的注解，这些注解实际上是Java标准JSR-303定义的，而且JDK本身不提供这些参数校验的实现。</p>
<p>Hibernate为JSR-303提供了一套实现，并在原先的基础上又扩展了一些功能，即Hibernate Validator，它可以单独引入使用，比如这样。</p>
<p><img src="1.png" alt="1"></p>
<p>Spring的不少模块都集成了Hibernate Validator，所以现在的主流的开发环境一般都是通过Spring或者Spring Boot的起步依赖将其引入的,比如spring-boot-starter-validation，其内部就包含了Hibernate Validator。在Hibernate的基础上，Spring Validation又提供了一系列AOP支持，使各种自定义的Validator以及校验注解能更方便的整合进我们的Spring程序中。</p>
<p><img src="2.png" alt="2"></p>
<p>如此，JSR-303、HIbernate Validator以及Spring Validation之间的关系就明朗了。</p>
<p>JSR-303 &lt;– Hibernate Validator实现 &lt;–Spring Validation二次封装</p>
<h1 id="Spring-Validation的功能"><a href="#Spring-Validation的功能" class="headerlink" title="Spring Validation的功能"></a>Spring Validation的功能</h1><h2 id="Request-Body校验"><a href="#Request-Body校验" class="headerlink" title="Request Body校验"></a>Request Body校验</h2><p>大部人最先接触到的一般是Spring MVC的Controller层入参校验，比如下面这个例子。</p>
<p><img src="3.png" alt="3"></p>
<p>RequestBody绑定了一个DTO（Data Transfer Object）对象，里面的一些字段需要进行校验。</p>
<p><img src="4.png" alt="4"></p>
<p>在Controller方法的入参前面加上一个@Valid注解，Spring Validation就会自动校验DTO中的数据，若一个或多个字段没通过校验，那么就会抛出MethodArgumentNotValidException。</p>
<p>这里的Valid注解是JSR-303定义的，可以替换为@Validated注解，它是SpringValidation提供的，虽然两者功能不同，但在这个场景下，它们作用是一样的。</p>
<p>稍微复杂有点的情况是，如果DTO中又包含了另一个需要校验的复杂对象，比如下面这个例子。</p>
<p><img src="7.png" alt="7"></p>
<p>假设NameBo里也有一些需要校验的字段，那么应该在NameBo字段上再加一个@Valid注解，当Spring检测到这个NameBo字段时，会递归进行校验，可以看看@Valid注解的源码。</p>
<p><img src="8.png" alt="8"></p>
<p>源码的注释已经说明了，这种校验行为会递归进行。</p>
<h2 id="方法入参校验"><a href="#方法入参校验" class="headerlink" title="方法入参校验"></a>方法入参校验</h2><p>有时候我们希望不只是在Controller层进行校验，而是在各种各样的地方应用校验，比如Service层，也希望能对平铺开来的参数进行校验，而不单纯的是对DTO进行校验，比如下面这样。</p>
<p><img src="5.png" alt="5"></p>
<p>但与Controller层的情况稍微不同了，在非Controller类中想要让Spring自动校验，需要在类定义加上一个@Validated注解。</p>
<p><img src="6.png" alt="6"></p>
<p>如此一来，MyService类中的所有方法，一旦入参上加了校验注解，都会被SpringValidation处理，如果有参数没通过校验，抛出的是ConstraintViolationException，与前面提到的MethodArgumentNotValidException不同，ConstraintViolationException是JSR-303提供的，而它是Spring提供的。</p>
<p>如果想要对Controller内的入参（不是RequestBody）进行校验，也需要在Controller类上加@Validated注解，比如下面这个例子，是对PathVariable和RequestParam进行校验。</p>
<p><img src="9.png" alt="9"></p>
<p>如果想要在Service层对DTO内的字段进行校验，在Service类上已经使用了@Validated注解的前提下，只需要在DTO入参的前面加上@Valid注解即可。</p>
<p><img src="10.png" alt="10"></p>
<h1 id="自定义校验规则"><a href="#自定义校验规则" class="headerlink" title="自定义校验规则"></a>自定义校验规则</h1><h2 id="定义Validator"><a href="#定义Validator" class="headerlink" title="定义Validator"></a>定义Validator</h2><p>相信你已经发现了，JSR-303这一套校验规范实际上是围绕注解展开的，比如@NotNull、@NotEmpty这些，针对这些JSR-303已有的注解，SpringValidation或者HibernateValidator实现了一部分，但如果现在有一个自定义的DTO类，需要同时检查多个字段，比如下面这个类。</p>
<p><img src="11.png" alt="11"></p>
<p>按照User类的定义，对其进行校验时需要同时检查username和password，单检查一个username或者单检查一个password都是没有意义的，此时预设的注解就无法满足我们的需求了，我们自己手动写一套校验规则。</p>
<p>首先写自定义类型的校验器，实现ConstraintValidator接口，第一个泛型是我们自定义的校验注解，后面会讲到，第二个泛型是我们要校验的类型，这里我们要同时检查username和password，所以直接检查整个User对象。</p>
<p><img src="12.png" alt="12"></p>
<p>一般来说重写isValid方法即可，校验时调用的是这个方法,如果isValid返回true，则说明校验通过，程序正常运行，若返回false，则校验不通过，触发ConstraintViolationException。</p>
<h2 id="自定义校验注解"><a href="#自定义校验注解" class="headerlink" title="自定义校验注解"></a>自定义校验注解</h2><p>有了Validator还不够，因为此时Spring的校验代理还不知道应该对User执行UserValidator的校验方法，为了让Spring去自动校验User，我们要写一个自定义注解标注在User类上，就像给一个产品打上标签，指明它该使用哪种机器处理。</p>
<p><img src="13.png" alt="13"></p>
<p>由于要校验的是整个User类，所以@Target指定的是TYPE，@Constraint(validatedBy=UserValidator.class)则代表这个注解所标注的类应该被UserVlidator校验。</p>
<p>message方法有一个默认返回值，这里指定未通过校验时的message；groups方法是用于分组校验的，分组是什么概念？你可以理解为类似于Spring Profile的一种东西，指明了哪个分组下应该检查User，哪些分组下不应该检查User，具体的会在后续文章中说明，这里不展开。</p>
<p><img src="14.png" alt="14"></p>
<p>最后将UserValid注解标注在User类上，如上图所示，在Controller层或者Service层使用Valid注解做DTO校验的标注。</p>
<p><img src="15.png" alt="15"></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本文介绍了SpringValidation与JSR-303、HibernateValidator的关系，并简单的对其使用进行了说明，但SpringValidation的功能实际上还不止如此，比如手动调用Validator、分组校验等等，后续文章会补全这些内容。</p>
<h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><p><a href="https://reflectoring.io/bean-validation-with-spring-boot/">Complete Guide to Validation With Spring Boot</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/205151764">Spring Validation最佳实践与实现原理</a></p>
]]></content>
      <categories>
        <category>Spring</category>
        <category>SpringValidation</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>数据校验</tag>
        <tag>HibernateValidator</tag>
        <tag>SpringValidation</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringValidation使用指南--手动与分组校验以及自定义异常处理</title>
    <url>/2021/03/17/SpringValidation%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97-%E6%89%8B%E5%8A%A8%E4%B8%8E%E5%88%86%E7%BB%84%E6%A0%A1%E9%AA%8C/</url>
    <content><![CDATA[<p>上一篇文章主要讲了如何利用SpringValidation提供的便利，来进行多种场景下的自动数据校验，虽然功能很强，但有时候我们想要自己触发校验机制，将主动权掌握在自己手中，而不是将校验时机完全交给Spring，那么可以不使用方法入参校验。</p>
<h1 id="手动触发校验"><a href="#手动触发校验" class="headerlink" title="手动触发校验"></a>手动触发校验</h1><p>手动触发校验，或者说编程式数据校验，依赖于javax.Validator这个类来进行。</p>
<p><img src="1.png" alt="1"></p>
<p>如果你引入了spring-boot-starter-validation这个起步依赖，那么Spring会为你自动预配置一个Validator的bean，你只需要注入到你想要的地方用就可以了。</p>
<p>上图中，使用Validator的validate方法可以校验User类，User类定义的结构如下，有两个JSR-303的校验注解和一个自定义校验注解。</p>
<p><img src="2.png" alt="2"></p>
<p>可以看到，方法的返回值是一个Set&lt;ConstraintViolation&lt;User&gt;&gt;，即校验出的所有不规范的字段，我们可以自由处理这些信息，比如可以像下面这样。</p>
<p><img src="3.png" alt="3"></p>
<p>还有其他更多的ConstraintViolation的用法，这里不展开说。实际上最常见的做法就是像第一张图里那样，用Set构造一个ConstraintViolationException抛出。</p>
<h1 id="分组校验"><a href="#分组校验" class="headerlink" title="分组校验"></a>分组校验</h1><p>假设我们的User类有一个Id属性，它对应的是User表的主键。用过JPA或者Hibernate的朋友应该知道，插入数据时，我们一般指定自己需要的属性，但不主动指定Id这个字段，因为我们想要让JPA/Hibernate自己生成主键；而更新数据时，一般是先从数据库里查出一条记录，在Entity对象上set过属性后，再save进数据库，这个过程中，id由于之前被插进去，所以不是null。</p>
<p>假设现在我想要在插入的方法上进行校验，要求User的id为null，而在更新的方法上进行校验时，id不能为null，要实现这个需求，使用分组校验正合适。</p>
<h2 id="定义分组标志"><a href="#定义分组标志" class="headerlink" title="定义分组标志"></a>定义分组标志</h2><p>首先定义两个空接口OnUpdate和OnInsert，它们不用有任何方法，实际上我们只是拿它们作为一个分组标识。</p>
<p><img src="4.png" alt="image-20210317232603803"></p>
<p>User类定义如下，可以看到对于id属性，指定了NotNull和Null，而且指定了groups属性，如此一来，两个校验注解就不会同时生效，只有当OnUpdate的时候，NotNull会生效，只有当OnInsert的时候，Null会生效。</p>
<p><img src="5.png" alt="5"></p>
<h2 id="指定方法所使用的分组"><a href="#指定方法所使用的分组" class="headerlink" title="指定方法所使用的分组"></a>指定方法所使用的分组</h2><p>那么如何决定何时启用OnUpdate和OnInsert呢？也许你已经注意到了，Spring提供的Vlidated注解是可以用在方法上的，但实际上Validated用在方法上必须配合分组的接口，比如下面这个例子。</p>
<p><img src="6.png" alt="6"></p>
<p>假设我们在Service层使用校验，在Service类上先加上Validated注解，如此一来，MyService中的所有方法都具有了数据校验的能力；其次在方法上指定Validated注解，我们希望对于updateUser方法指定的是OnUpdate的情景，对insertUser方法指定的是OnInsert的情景，在方法的User入参上使用Valid注解，只有这样，才会在方法调用时进行校验。</p>
<h2 id="自定义校验注解中的groups属性"><a href="#自定义校验注解中的groups属性" class="headerlink" title="自定义校验注解中的groups属性"></a>自定义校验注解中的groups属性</h2><p>前一篇文章讲过如何使用自定义校验注解，来执行我们自己的校验逻辑，比如下面这个校验注解。</p>
<p><img src="12.png" alt="12"></p>
<p>可以看到其中有一个groups属性，这个groups属性其实就跟我们上面使用的groups属性作用完全一致，NotNull、NotEmpty、NotBlank这些注解也统统都包含了groups属性，所以，如果我们想要对一个自定义校验注解进行分组校验，那么标注在校验处时使用groups属性即可，比如下面这个例子。</p>
<p><img src="13.png" alt="13"></p>
<h1 id="自定义异常处理"><a href="#自定义异常处理" class="headerlink" title="自定义异常处理"></a>自定义异常处理</h1><p>虽然我们可以指定一个字段校验不通过时所输出的message，但实际上，默认的异常处理相当粗糙，放一张图感受一下。</p>
<p><img src="7.png" alt="7"></p>
<p>我们其实并不需要过于完整的报错信息，只是想看到哪个字段违反了哪个校验规则，所以这个信息只能自己处理了。</p>
<h2 id="两种校验异常"><a href="#两种校验异常" class="headerlink" title="两种校验异常"></a>两种校验异常</h2><p>此外，之前一篇文章曾经提过SpringValidation相关的两个异常，MethodArgumentNotValidException和ConstraintViolationException，前者是在Controller层校验失败时抛出的异常，并且报的是http 400的Bad Request，后者则是在非Controller层校验失败时抛出的异常，报的是http 500的Internal Server Error，这个两个异常其实有必要进行统一处理。</p>
<p>那么需求就明确了，我们希望返回给前端的是简单的校验结果，即字段名和message的组合，同时又希望统一处理两种异常，返回http 400 BadRequest错误。</p>
<h2 id="自定义校验结果返回数据"><a href="#自定义校验结果返回数据" class="headerlink" title="自定义校验结果返回数据"></a>自定义校验结果返回数据</h2><p>按照需求，我们可以写一个建议的自定义校验结果类，ValidationResult里包含一个ValidationError列表，列表中的每个元素都包含一个字段和其校验失败的message，最终我们将会把这个类作为json数据返回给前端。</p>
<p><img src="8.png" alt="8"></p>
<h2 id="全局异常处理"><a href="#全局异常处理" class="headerlink" title="全局异常处理"></a>全局异常处理</h2><p>定义一个类并用ControllerAdive标注，如此一来，里面的异常处理方法就会对所有的Controller生效；用ExceptionHandler来标注异常处理的方法，指定要处理哪种异常；ResponseStatus用来指定返回给前端的是哪种http响应码，ResponseBody用来将返回值转换为json数据响应给前端，一般来说，只要你的项目中引入了spring-boot-starter-web，就会包含jackson的包，使用ResponseBody就能自动将Controller返回值转换为json格式。</p>
<p><img src="9.png" alt="9"></p>
<p>注意还需要处理MethodArgumentNotValidException。</p>
<p><img src="10.png" alt="10"></p>
<p>这次再违反一次数据校验规则，来看看返回的结果，格式清爽了不少，而且清一色的都是返回http 400 BadRequest。</p>
<p><img src="11.png" alt="11"></p>
<h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><p><a href="https://reflectoring.io/bean-validation-with-spring-boot/">Complete Guide to Validation With Spring Boot</a></p>
]]></content>
      <categories>
        <category>Spring</category>
        <category>SpringValidation</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>数据校验</tag>
        <tag>HibernateValidator</tag>
        <tag>SpringValidation</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringWebFlow入门及案例</title>
    <url>/2021/03/01/SpringWebFlow%E5%85%A5%E9%97%A8%E5%8F%8A%E6%A1%88%E4%BE%8B/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>一般我们在构建基于模板的Web应用时，会使用SpringMVC，模板技术可能会选择jsp、thymeleaf、freemarker等，如果Model、View、Controller各层次之间的交互和跳转比较简单的话，自然是再好不过的了，但如果比较复杂的话，那么一般的MVC模式就显得吃力不讨好了。</p>
<p>SpringWebFlow是一种基于SpringMVC的web流程框架，我们可以用它来管理Model和View的交互，是的，你没看错，甚至连一个Controller也不需要写，就可以完成一整个Web应用。</p>
<p>我们的Web应用一般都是以一个个<strong>流程</strong>组成的，比如现在有这样一个需求，披萨店需要一个Web应用来让客户订购披萨，将整个应用转换为流程，如下图所示。</p>
<p><img src="1.png" alt="1"></p>
<p>整个流程无非就是识别用户-&gt;创建订单-&gt;支付订单-&gt;保存订单，使用SpringWebFlow可以很直观的将它实现，而不需要写Controller层。</p>
<h1 id="流程基本概念"><a href="#流程基本概念" class="headerlink" title="流程基本概念"></a>流程基本概念</h1><p>在Spring Web Flow中，有三个主要的组成部分，即状态(state)、转移(transition)、流程数据。</p>
<p>假设一个完整流程是这样的。</p>
<p>A-&gt;B-&gt;C</p>
<p>那么A、B、C三个节点就是状态，而转移是三个节点之间的横线，它关注的是如何从一个状态转到另一个状态，在几个节点之间传递的就是流程数据。</p>
<h2 id="状态"><a href="#状态" class="headerlink" title="状态"></a>状态</h2><p>状态有5种类型。</p>
<table>
<thead>
<tr>
<th>状态类型</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>行为（Action）</td>
<td>简单地执行逻辑</td>
</tr>
<tr>
<td>决策（Decision）</td>
<td>即分支节点，根据运行结果决定走向哪个状态</td>
</tr>
<tr>
<td>结束（End）</td>
<td>执行结束状态后，整个流程宣告结束</td>
</tr>
<tr>
<td>子流程（Subflow）</td>
<td>在当前状态的上下文中启动一个全新的流程，子流程走完以后继续原流程的执行，也就是说一个节点代表一个流程</td>
</tr>
<tr>
<td>视图（View）</td>
<td>将视图返回给用户，用户使用完视图后，才继续执行原流程</td>
</tr>
</tbody></table>
<h3 id="视图状态"><a href="#视图状态" class="headerlink" title="视图状态"></a>视图状态</h3><p>一般来说，如果没有视图状态，则整个流程是根据用户最开始的输入自动执行的。</p>
<p>而如果在流程中中定义了一个视图状态（View State），则会向用户展示一个视图，用户通过视图进行输入，从而影响到流程后续走向。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">view-state</span> <span class="attr">id</span>=<span class="string">&quot;welcome&quot;</span> <span class="attr">view</span>=<span class="string">&quot;greeting&quot;</span> <span class="attr">model</span>=<span class="string">&quot;flowScope.paymentDetails&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p>用view-state标签来表示视图状态，如果只提供一个id，比如id=”welcome”，则代表该状态的id为welcome，其对应的视图名也为welcome；提供view属性可以指定该state对应的view名；提供model属性可以指定该view绑定一个model对象，比如上面的例子，从flow作用域中取出paymentDetails对象，并交给greeting视图使用。</p>
<h3 id="行为状态"><a href="#行为状态" class="headerlink" title="行为状态"></a>行为状态</h3><p>简单执行一些逻辑，并转移到另一个状态。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">action-state</span> <span class="attr">id</span>=<span class="string">&quot;saveOrder&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="tag">&lt;<span class="name">evaluate</span> <span class="attr">expression</span>=<span class="string">&quot;pizzaFlowActions.saveOrder(order)&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="tag">&lt;<span class="name">transition</span> <span class="attr">to</span>=<span class="string">&quot;thankYou&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">action-state</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>evaluate子标签可以填一个表达式（可以是SpEL、OGNL、Unified EL），比如上面的例子中，代表要执行pizzaFlowActions这个bean里的saveOrder方法。</p>
<p>transition子标签指明下一个状态走哪个，上面的例子中，下一个状态是thankYou。</p>
<h3 id="决策状态"><a href="#决策状态" class="headerlink" title="决策状态"></a>决策状态</h3><p>根据表达式的返回值是true或false决定后续往哪个状态走。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">decision-state</span> <span class="attr">id</span>=<span class="string">&quot;checkDeliveryArea&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;pizzaFlowActions.checkDeliveryArea(customer.zipCode)&quot;</span> </span></span><br><span class="line"><span class="tag"></span></span><br><span class="line"><span class="tag">		<span class="attr">then</span>=<span class="string">&quot;addCustomer&quot;</span></span></span><br><span class="line"><span class="tag"></span></span><br><span class="line"><span class="tag">		<span class="attr">else</span>=<span class="string">&quot;deliveryWarning&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">decision-state</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>比如上面这个例子中，根据pizzaFlowActions的checkDeliveryArea方法的返回值决定下一个状态走addCustomer还是走deliverWarning</p>
<h3 id="子流程状态"><a href="#子流程状态" class="headerlink" title="子流程状态"></a>子流程状态</h3><p>即一个节点对应一个独立的流程，这个独立流程走完后才返回原流程执行，可以类比成在一个方法中调用另一个方法。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">subflow-state</span> <span class="attr">id</span>=<span class="string">&quot;order&quot;</span> <span class="attr">subflow</span>=<span class="string">&quot;pizza/order&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">&quot;order&quot;</span> <span class="attr">value</span>=<span class="string">&quot;order&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="tag">&lt;<span class="name">transition</span> <span class="attr">on</span>=<span class="string">&quot;orderCreated&quot;</span> <span class="attr">to</span>=<span class="string">&quot;payment&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">subflow-state</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>上面这个例子中，状态名为order，它所对应的子流程为pizza/order，input标签指明了子流程的输入，即order对象，transition标签指出了当子流程的end-state即orderCreated执行完后，原流程order将转移到payment状态。</p>
<h3 id="结束状态"><a href="#结束状态" class="headerlink" title="结束状态"></a>结束状态</h3><p>结束状态执行完后，接下来发生什么？不一定</p>
<ul>
<li>如果这个end-state属于一个子流程，则这个end-state的id将作为一个事件，决定原流程接下来走哪个状态，可以参照子流程状态的例子。</li>
<li>如果end-state设置了view属性，则将展示指定的视图（相对于流程路径的视图模板），如果view属性加上externalRedirect的话，可以重定向到流程外部的页面；如果view属性加上flowRedirect前缀，将重定向到另一个流程中。</li>
<li>如果既没有设置view也不是属于子流程，则流程结束，等待用户输入并执行下一个流程。</li>
</ul>
<h2 id="转移"><a href="#转移" class="headerlink" title="转移"></a>转移</h2><p>转移是流程中各状态的连接线，可以用于action-state、view-state、subflow-state（end-state是最终节点，而decisition-state不需要指定transition）。</p>
<p>一个最简单的转移可以这样定义。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">transition</span> <span class="attr">to</span>=<span class="string">&quot;customerReady&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p>即直接指明了后面转移到customerReady状态，只有在当前状态单一出口时才可以这样定义。</p>
<p>如果当前状态有多个出口，那么就需要根据on属性来决定走哪个转移，on属性绑定了一个事件。</p>
<p>比如<transition on="phoneEntered" to="lookupCustomer"/></p>
<p>视图状态是根据用户在视图的输入产生相应的on事件，在行为状态中，事件是evaluate表达式执行的结果，在子流程状态中，事件是子流程的结束状态的id。</p>
<p>或者也可以根据抛出的异常决定转移到哪个状态。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">transition</span> <span class="attr">on-exception</span>=<span class="string">&quot;com.springinaction.pizza.service.CustomerNotFoundException&quot;</span> <span class="attr">to</span>=<span class="string">&quot;regisrationForm&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="全局转移"><a href="#全局转移" class="headerlink" title="全局转移"></a>全局转移</h3><p>如果某些转移需要被引用多次，可以将其定义为全局转移。</p>
<p>transition可以定义为global-transition的子元素。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">global-transition</span>&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="tag">&lt;<span class="name">transition</span> <span class="attr">on-exception</span>=<span class="string">&quot;a&quot;</span> <span class="attr">to</span>=<span class="string">&quot;b&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">global-transition</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>比如上面这个例子，所有的状态都将拥有这个转移，当前状态抛出a异常，则转移到b状态。</p>
<h2 id="流程数据"><a href="#流程数据" class="headerlink" title="流程数据"></a>流程数据</h2><p>流程数据是保存在变量中的，可以设置这些数据的作用于，是只能在视图里访问？还是只能在当前流程访问？还是能被多个流程访问？</p>
<p>最简单的变量可以这样定义，这种变量将在整个流程内有效。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">var</span> <span class="attr">name</span>=<span class="string">&quot;cutomer&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.springinaction.pizza.domain.Customer&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p>也可以用evaluate或者set元素来声明变量，比如下面这样。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">evaluate</span> <span class="attr">expression</span>=<span class="string">&quot;T(com.springinaction.pizza.domain.Topping.asList())&quot;</span> <span class="attr">result</span>=<span class="string">&quot;viewScope.toppingsList&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p>上面的例子中，执行了expression，并将表达式结果放到viewScope中的toppingsList变量内。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">set</span> <span class="attr">name</span>=<span class="string">&quot;flowScope.pizza&quot;</span> <span class="attr">value</span>=<span class="string">&quot;new com.springinaction.pizza.domain.Pizza()&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p>上面的例子中，将new出来的Pizza对象放到flowScope的pizza变量内。</p>
<h3 id="数据作用域"><a href="#数据作用域" class="headerlink" title="数据作用域"></a>数据作用域</h3><p>有5种作用域。</p>
<table>
<thead>
<tr>
<th>范围</th>
<th>可见性</th>
</tr>
</thead>
<tbody><tr>
<td>Conversation</td>
<td>在整个流程包括其子流程内可用</td>
</tr>
<tr>
<td>Flow</td>
<td>在当前流程内可用，可能局限于一个子流程内</td>
</tr>
<tr>
<td>Request</td>
<td>一个请求内可用，如果一个请求内走了多个流程（比如重定向了多次），则这些流程都可用</td>
</tr>
<tr>
<td>Flash</td>
<td>从当前流程开始时可用，如果在这个流程中渲染了视图，则数据会被清除，如果没渲染视图，则一直可用</td>
</tr>
<tr>
<td>View</td>
<td>只在视图状态下可用</td>
</tr>
</tbody></table>
<h1 id="完整案例：披萨订购"><a href="#完整案例：披萨订购" class="headerlink" title="完整案例：披萨订购"></a>完整案例：披萨订购</h1><p>这个案例将完整讲述从流程抽象、配置，到实现的过程，是我从Spring实战第四版书上找到的，原书的代码只有一部分，我根据原有代码结合整个流程，实现了一遍。</p>
<h2 id="Maven依赖"><a href="#Maven依赖" class="headerlink" title="Maven依赖"></a>Maven依赖</h2><p>注意除了SpringMVC依赖外，还需要引入SpringWebFlow的依赖，此外为了方便我们写View层的代码，也要引入JSTL。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.11<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-beans<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.2.12.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.2.12.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.2.12.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.2.12.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-webmvc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.2.12.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.webflow<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-webflow<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.5.1.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.18.16<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>jstl<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jstl<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>除了对SpringMVC进行配置以外，还需要对SpringWebFlow进行配置，下面将分别对各个配置文件进行展示。</p>
<h3 id="web-xml"><a href="#web-xml" class="headerlink" title="web.xml"></a>web.xml</h3><p>这边只需要配置一个DispatcherServlet即可，可以顺手把Spring配置文件也指定了，比如这个例子中是/WEB-INF/applicationContext.xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">web-app</span> <span class="meta-keyword">PUBLIC</span></span></span><br><span class="line"><span class="meta"> <span class="meta-string">&quot;-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN&quot;</span></span></span><br><span class="line"><span class="meta"> <span class="meta-string">&quot;http://java.sun.com/dtd/web-app_2_3.dtd&quot;</span> &gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">display-name</span>&gt;</span>Archetype Created Web Application<span class="tag">&lt;/<span class="name">display-name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">listener</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">listener-class</span>&gt;</span>org.springframework.web.context.ContextLoaderListener<span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>dispatcherServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>/WEB-INF/applicationContext.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>dispatcherServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">welcome-file-list</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">welcome-file</span>&gt;</span>/WEB-INF/jsp/index.jsp<span class="tag">&lt;/<span class="name">welcome-file</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">welcome-file-list</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="SpringMVC配置"><a href="#SpringMVC配置" class="headerlink" title="SpringMVC配置"></a>SpringMVC配置</h3><p>SpringMVC只需要简单给其配置一个视图解析器即可，我这里单独建了一个文件web-mvc.xml，将其放在classpath下。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:mvc</span>=<span class="string">&quot;http://www.springframework.org/schema/mvc&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;viewResolver&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;viewClass&quot;</span> <span class="attr">value</span>=<span class="string">&quot;org.springframework.web.servlet.view.JstlView&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;prefix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;/WEB-INF/jsp/&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;suffix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;.jsp&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="SpringWebFlow配置"><a href="#SpringWebFlow配置" class="headerlink" title="SpringWebFlow配置"></a>SpringWebFlow配置</h3><p>这个例子中，我将SpringWebFlow的配置全都写在classpath下的web-flow.xml中。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:flow</span>=<span class="string">&quot;http://www.springframework.org/schema/webflow-config&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;</span></span></span><br><span class="line"><span class="tag"><span class="string">           http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">           http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">           http://www.springframework.org/schema/webflow-config</span></span></span><br><span class="line"><span class="tag"><span class="string">           http://www.springframework.org/schema/webflow-config/spring-webflow-config.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    //流程执行器，用来管理flowRegistry</span><br><span class="line">    <span class="tag">&lt;<span class="name">flow:flow-executor</span> <span class="attr">id</span>=<span class="string">&quot;flowExecutor&quot;</span> <span class="attr">flow-registry</span>=<span class="string">&quot;flowRegistry&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    //注册流程，这里我将所有的flow都放在了/WEB-INF/flows/pizza目录下，并且每个流程定义都以-flow.xml结尾</span><br><span class="line">    <span class="tag">&lt;<span class="name">flow:flow-registry</span> <span class="attr">id</span>=<span class="string">&quot;flowRegistry&quot;</span> <span class="attr">flow-builder-services</span>=<span class="string">&quot;flowBuilderServices&quot;</span> <span class="attr">base-path</span>=<span class="string">&quot;/WEB-INF/flows/pizza&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">flow:flow-location-pattern</span> <span class="attr">value</span>=<span class="string">&quot;*-flow.xml&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">flow:flow-registry</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    //为了让SpringWebFlow的视图解析通过我们已经配置好的视图解析器，配置一个flow-builder-services，将view-factory-creator指定为一个自定义的mvcViewFactoryCreator</span><br><span class="line">    <span class="tag">&lt;<span class="name">flow:flow-builder-services</span> <span class="attr">id</span>=<span class="string">&quot;flowBuilderServices&quot;</span> <span class="attr">view-factory-creator</span>=<span class="string">&quot;mvcViewFactoryCreator&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;mvcViewFactoryCreator&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.webflow.mvc.builder.MvcViewFactoryCreator&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;viewResolvers&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;viewResolver&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    //将flowExecutor指定给FlowHandlerAdapater，可以类比成SpringMVC的HandlerAdapter，即可以像访问普通Controller接口那样访问流程</span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;flowHandlerAdapter&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.webflow.mvc.servlet.FlowHandlerAdapter&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;flowExecutor&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;flowExecutor&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    //流程与Controller接口的映射，</span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.webflow.mvc.servlet.FlowHandlerMapping&quot;</span> <span class="attr">id</span>=<span class="string">&quot;flowHandlerMapping&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;flowRegistry&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;flowRegistry&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="Spring主配置文件"><a href="#Spring主配置文件" class="headerlink" title="Spring主配置文件"></a>Spring主配置文件</h3><p>这边是最简单的，直接导入我们已经写好的web-mvc.xml和web-flow.xml即可，由于这个案例没有使用SpringBoot，所以顺手写一个自动组件扫描的配置。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">import</span> <span class="attr">resource</span>=<span class="string">&quot;classpath:web-mvc.xml&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">import</span> <span class="attr">resource</span>=<span class="string">&quot;classpath:web-flow.xml&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;org.zh.pizza&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:annotation-config</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="流程实现"><a href="#流程实现" class="headerlink" title="流程实现"></a>流程实现</h2><p>整个项目实际上是一个主流程，其内部包含了若干个子流程，下面就先介绍主流程spizza-flow。</p>
<h3 id="spizza-flow主流程"><a href="#spizza-flow主流程" class="headerlink" title="spizza-flow主流程"></a>spizza-flow主流程</h3><p>主流程的图示如下，简单介绍一下，首先进入identifyCustomer子流程，即识别用户，识别完成后，触发customerReady转移，如前文所介绍的，你可以把转移视为一种事件，即identifyCustomer这个流程触发了customerReady这个事件；后续的builderOrder、takePayment都是子流程，而saveOrder是一个动作状态，thankCustomer是一个视图状态，整个流程走完后，回到start处重新开始。</p>
<p><img src="1.png" alt="1"></p>
<p>看看spizza-flow的xml定义，如下图所示。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">flow</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/webflow&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/webflow</span></span></span><br><span class="line"><span class="tag"><span class="string">      http://www.springframework.org/schema/webflow/spring-webflow-2.0.xsd&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">start-state</span>=<span class="string">&quot;identifyCustomer&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    //Order作为整个流程贯穿始终的参数，使用var标签定义</span><br><span class="line">    <span class="tag">&lt;<span class="name">var</span> <span class="attr">name</span>=<span class="string">&quot;order&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.zh.pizza.domain.Order&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    //identifyCustomer子流程，使用subflow属性来指向另一个流程</span><br><span class="line">    <span class="tag">&lt;<span class="name">subflow-state</span> <span class="attr">id</span>=<span class="string">&quot;identifyCustomer&quot;</span> <span class="attr">subflow</span>=<span class="string">&quot;customer-flow&quot;</span>&gt;</span></span><br><span class="line">        //output可以理解为identifyCustomer这个流程的返回值,value属性为Spel表达式</span><br><span class="line">        <span class="tag">&lt;<span class="name">output</span> <span class="attr">name</span>=<span class="string">&quot;customer&quot;</span> <span class="attr">value</span>=<span class="string">&quot;order.customer&quot;</span>/&gt;</span></span><br><span class="line">        //触发customerReady转移，跳转至下一个子流程buildeOrder</span><br><span class="line">        <span class="tag">&lt;<span class="name">transition</span> <span class="attr">on</span>=<span class="string">&quot;customerReady&quot;</span> <span class="attr">to</span>=<span class="string">&quot;buildOrder&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">subflow-state</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">subflow-state</span> <span class="attr">id</span>=<span class="string">&quot;buildOrder&quot;</span> <span class="attr">subflow</span>=<span class="string">&quot;order-flow&quot;</span>&gt;</span></span><br><span class="line">        //由于builderOrder内部需要用到order对象，所以使用input标签作为该子流程的入参</span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">&quot;order&quot;</span> <span class="attr">value</span>=<span class="string">&quot;order&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">transition</span> <span class="attr">on</span>=<span class="string">&quot;orderCreated&quot;</span> <span class="attr">to</span>=<span class="string">&quot;takePayment&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">subflow-state</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">subflow-state</span> <span class="attr">id</span>=<span class="string">&quot;takePayment&quot;</span> <span class="attr">subflow</span>=<span class="string">&quot;payment-flow&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">&quot;order&quot;</span> <span class="attr">value</span>=<span class="string">&quot;order&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">transition</span> <span class="attr">on</span>=<span class="string">&quot;paymentTaken&quot;</span> <span class="attr">to</span>=<span class="string">&quot;saveOrder&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">subflow-state</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">action-state</span> <span class="attr">id</span>=<span class="string">&quot;saveOrder&quot;</span>&gt;</span></span><br><span class="line">        //evaluate可以用来处理一个Spel表达式</span><br><span class="line">        <span class="tag">&lt;<span class="name">evaluate</span> <span class="attr">expression</span>=<span class="string">&quot;pizzaFlowActions.saveOrder(order)&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">transition</span> <span class="attr">to</span>=<span class="string">&quot;thankCustomer&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">action-state</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">view-state</span> <span class="attr">id</span>=<span class="string">&quot;thankCustomer&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">transition</span> <span class="attr">to</span>=<span class="string">&quot;endState&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">view-state</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    //整个流程结束</span><br><span class="line">    <span class="tag">&lt;<span class="name">end-state</span> <span class="attr">id</span>=<span class="string">&quot;endState&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">global-transitions</span>&gt;</span></span><br><span class="line">        //如果在任意的流程中触发了cancel转移，则直接跳转至endState</span><br><span class="line">        <span class="tag">&lt;<span class="name">transition</span> <span class="attr">on</span>=<span class="string">&quot;cancel&quot;</span> <span class="attr">to</span>=<span class="string">&quot;endState&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">global-transitions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">flow</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这里不关注Spel表达式背后的具体方法实现，如果你想要自己实现，可以直接到我的Github下载源码，地址贴在本文最后。</p>
<p>接下来会分别介绍各个子流程。</p>
<h3 id="identifyCustomer子流程"><a href="#identifyCustomer子流程" class="headerlink" title="identifyCustomer子流程"></a>identifyCustomer子流程</h3><p>identifyCustomer是这个子流程的id，而真正的流程定义是写在customer-flow.xml内的，这点需要注意一下。</p>
<p>可以注意到，identifyCustomer子流程并没有任何输入变量，也就是说这个流程的角色是一个单纯的生产者。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">flow</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/webflow&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/webflow</span></span></span><br><span class="line"><span class="tag"><span class="string">      http://www.springframework.org/schema/webflow/spring-webflow-2.0.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    //定义子流程的全局变量customer</span><br><span class="line">    <span class="tag">&lt;<span class="name">var</span> <span class="attr">name</span>=<span class="string">&quot;customer&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.zh.pizza.domain.Customer&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    //进入welcome视图，这里需要注意以下一般视图状态对应的是同名的视图，即welcome状态对应welcome.jsp视图</span><br><span class="line">    <span class="tag">&lt;<span class="name">view-state</span> <span class="attr">id</span>=<span class="string">&quot;welcome&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">transition</span> <span class="attr">on</span>=<span class="string">&quot;phoneEntered&quot;</span> <span class="attr">to</span>=<span class="string">&quot;lookupCustomer&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">view-state</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">action-state</span> <span class="attr">id</span>=<span class="string">&quot;lookupCustomer&quot;</span>&gt;</span></span><br><span class="line">        //检查用户输入的手机号是否存在，若不存在，触发CustomerNotFoundException，并转移至registrationForm视图；若用户输入的手机号存在，则转移至customerReady状态</span><br><span class="line">        <span class="tag">&lt;<span class="name">evaluate</span> <span class="attr">expression</span>=<span class="string">&quot;pizzaFlowActions.lookupCustomer(requestParameters.phoneNumber)&quot;</span> <span class="attr">result</span>=<span class="string">&quot;customer&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">transition</span> <span class="attr">on-exception</span>=<span class="string">&quot;org.zh.pizza.exception.CustomerNotFoundException&quot;</span> <span class="attr">to</span>=<span class="string">&quot;registrationForm&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">transition</span> <span class="attr">to</span>=<span class="string">&quot;customerReady&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">action-state</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    //注册表单视图，将customer绑定为该视图的model</span><br><span class="line">    <span class="tag">&lt;<span class="name">view-state</span> <span class="attr">id</span>=<span class="string">&quot;registrationForm&quot;</span> <span class="attr">model</span>=<span class="string">&quot;customer&quot;</span>&gt;</span></span><br><span class="line">        //on-entry的作用是在进入这个视图时做一些操作，比如这个例子中，是将lookupCustomer中用户输入的手机号绑定到customer对象内</span><br><span class="line">        <span class="tag">&lt;<span class="name">on-entry</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">evaluate</span> <span class="attr">expression</span>=<span class="string">&quot;customer.phoneNumber = requestParameters.phoneNumber&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">on-entry</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">transition</span> <span class="attr">to</span>=<span class="string">&quot;checkDeliveryArea&quot;</span> <span class="attr">on</span>=<span class="string">&quot;submit&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">view-state</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    //决策状态，通过checkDeliveryArea方法的执行结果，决定是进入addCustomer或者是deliveryWarning两个分支</span><br><span class="line">    <span class="tag">&lt;<span class="name">decision-state</span> <span class="attr">id</span>=<span class="string">&quot;checkDeliveryArea&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;pizzaFlowActions.checkDeliveryArea(customer.zipCode)&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">then</span>=<span class="string">&quot;addCustomer&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">else</span>=<span class="string">&quot;deliveryWarning&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">decision-state</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">view-state</span> <span class="attr">id</span>=<span class="string">&quot;deliveryWarning&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">transition</span> <span class="attr">on</span>=<span class="string">&quot;accept&quot;</span> <span class="attr">to</span>=<span class="string">&quot;addCustomer&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">view-state</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">action-state</span> <span class="attr">id</span>=<span class="string">&quot;addCustomer&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">evaluate</span> <span class="attr">expression</span>=<span class="string">&quot;pizzaFlowActions.addCustomer(customer)&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">transition</span> <span class="attr">to</span>=<span class="string">&quot;customerReady&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">action-state</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    //这里的end-state的id为cancel，这与外层主流程的global-transition的cancel转移是一样的，即这里触发cancel结束状态，回到原流程时，触发cancel转移</span><br><span class="line">    <span class="tag">&lt;<span class="name">end-state</span> <span class="attr">id</span>=<span class="string">&quot;cancel&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    //如果时进入的时customerReady的end-state，则返回原流程的同时，将customer作为返回值返回</span><br><span class="line">    <span class="tag">&lt;<span class="name">end-state</span> <span class="attr">id</span>=<span class="string">&quot;customerReady&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">output</span> <span class="attr">name</span>=<span class="string">&quot;customer&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">end-state</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">global-transitions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">transition</span> <span class="attr">on</span>=<span class="string">&quot;cancel&quot;</span> <span class="attr">to</span>=<span class="string">&quot;cancel&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">transition</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">global-transitions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">flow</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>来看看welcome视图的定义，实际上，在SpringWebFlow中，视图层要关心的东西并不多，只是作为一个人机交互的层次。但有一点时需要注意的，即即如何确定视图触发哪个转移（触发事件），以及怎么从视图回到原先的流程中，注意这里需要导入Spring标签库。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">&lt;%@ taglib prefix=&quot;form&quot; uri=&quot;http://www.springframework.org/tags/form&quot; %&gt;</span><br><span class="line">&lt;%--</span><br><span class="line">  Created by IntelliJ IDEA.</span><br><span class="line">  User: Administrator</span><br><span class="line">  Date: 2021/4/5</span><br><span class="line">  Time: 13:49</span><br><span class="line">  To change this template use File | Settings | File Templates.</span><br><span class="line">--%&gt;</span><br><span class="line">&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; isELIgnored=&quot;false&quot;%&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Spizza<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>Welcome to Spizza!!!<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form:form</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;hidden&quot;</span> <span class="attr">name</span>=<span class="string">&quot;_flowExecutionKey&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;flowExecutionKey&#125;&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;phoneNumber&quot;</span>/&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">name</span>=<span class="string">&quot;_eventId_phoneEntered&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Lookup Customer&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form:form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>现在来回答前面的两个问题，如何触发某个转移？将input的name设置为**_event_id_XXX**即可，其中XXX就是要触发的转移。如何从视图回到原先的流程里？在表单里设置一个隐藏域，name为_flowExecutionKey，值是从流程进入视图时自动带过来的，使用EL表达式获取它并设置到value里即可。注意这里一定得使用Spring标签库的form，否则flowExecutionKey和eventId都是不起作用的。</p>
<p>再看看deliveryWarning视图，它没有表单，但是它使用的是a标签去控制跳转。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">&lt;%--</span><br><span class="line">  Created by IntelliJ IDEA.</span><br><span class="line">  User: Administrator</span><br><span class="line">  Date: 2021/4/5</span><br><span class="line">  Time: 14:15</span><br><span class="line">  To change this template use File | Settings | File Templates.</span><br><span class="line">--%&gt;</span><br><span class="line">&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; isELIgnored=&quot;false&quot;%&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Spizza<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>Delivery Unavailable<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>The address is outside of our delivery area. You may still place the order, but you will need to pick it up yourself.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;$&#123;flowExecutionUrl&#125;&amp;_eventId=accept&quot;</span>&gt;</span>Continue, I&#x27;ll pick up the order<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;$&#123;flowExecutionUrl&#125;&amp;_eventId=cancel&quot;</span>&gt;</span>Never mind<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>注意，这里a标签使用了flowExecutionUrl，它代表的原流程的地址，回到原流程的同时，我们一般还会触发一个事件，所以也带上_eventId。</p>
<h3 id="buildOrder子流程"><a href="#buildOrder子流程" class="headerlink" title="buildOrder子流程"></a>buildOrder子流程</h3><p>buildOrder流程是与用户交互，生成订单的，用户可以订购一个或多个披萨。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">flow</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/webflow&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/webflow</span></span></span><br><span class="line"><span class="tag"><span class="string">      http://www.springframework.org/schema/webflow/spring-webflow-2.0.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    //将外部传进来的order对象作为本流程的全局参数</span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">&quot;order&quot;</span> <span class="attr">required</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">view-state</span> <span class="attr">id</span>=<span class="string">&quot;showOrder&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">transition</span> <span class="attr">on</span>=<span class="string">&quot;createPizza&quot;</span> <span class="attr">to</span>=<span class="string">&quot;createPizza&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">transition</span> <span class="attr">on</span>=<span class="string">&quot;checkout&quot;</span> <span class="attr">to</span>=<span class="string">&quot;orderCreated&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">transition</span> <span class="attr">on</span>=<span class="string">&quot;cancel&quot;</span> <span class="attr">to</span>=<span class="string">&quot;cancel&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">view-state</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    //将flow作用域的pizza作为model，进入createPizza视图</span><br><span class="line">    <span class="tag">&lt;<span class="name">view-state</span> <span class="attr">id</span>=<span class="string">&quot;createPizza&quot;</span> <span class="attr">model</span>=<span class="string">&quot;flowScope.pizza&quot;</span>&gt;</span></span><br><span class="line">        //进入createPizza视图时，自动new一个Pizza并放入flow作用域</span><br><span class="line">        <span class="tag">&lt;<span class="name">on-entry</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">set</span> <span class="attr">name</span>=<span class="string">&quot;flowScope.pizza&quot;</span> <span class="attr">value</span>=<span class="string">&quot;new org.zh.pizza.domain.Pizza()&quot;</span>/&gt;</span></span><br><span class="line">            //注意这里还执行了一下Topping类的静态方法asList，实际上Topping是个枚举类，即配料，将配料的枚举作为List放入view作用域</span><br><span class="line">            <span class="tag">&lt;<span class="name">evaluate</span> <span class="attr">expression</span>=<span class="string">&quot;T(org.zh.pizza.domain.Topping).asList()&quot;</span> <span class="attr">result</span>=<span class="string">&quot;viewScope.toppingsList&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">on-entry</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">transition</span> <span class="attr">on</span>=<span class="string">&quot;addPizza&quot;</span> <span class="attr">to</span>=<span class="string">&quot;showOrder&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">evaluate</span> <span class="attr">expression</span>=<span class="string">&quot;order.addPizza(flowScope.pizza)&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">transition</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">transition</span> <span class="attr">on</span>=<span class="string">&quot;cancel&quot;</span> <span class="attr">to</span>=<span class="string">&quot;showOrder&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">transition</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">view-state</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">end-state</span> <span class="attr">id</span>=<span class="string">&quot;cancel&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">end-state</span> <span class="attr">id</span>=<span class="string">&quot;orderCreated&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">flow</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>先看看showOrder视图，这是buildOrder子流程的一个主要视图，主要是显示用户已经点过的披萨和配料，除了查看订单，还可以继续创建披萨或者直接进入支付流程。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">&lt;%@ taglib prefix=&quot;form&quot; uri=&quot;http://www.springframework.org/tags/form&quot; %&gt;</span><br><span class="line">&lt;%--</span><br><span class="line">  Created by IntelliJ IDEA.</span><br><span class="line">  User: Administrator</span><br><span class="line">  Date: 2021/4/5</span><br><span class="line">  Time: 15:01</span><br><span class="line">  To change this template use File | Settings | File Templates.</span><br><span class="line">--%&gt;</span><br><span class="line">&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; isELIgnored=&quot;false&quot; %&gt;</span><br><span class="line">&lt;%@ taglib uri=&quot;http://java.sun.com/jsp/jstl/core&quot; prefix=&quot;c&quot; %&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Spizza<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>Pizza Status<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">c:forEach</span> <span class="attr">var</span>=<span class="string">&quot;pizza&quot;</span> <span class="attr">items</span>=<span class="string">&quot;$&#123;order.pizzas&#125;&quot;</span>&gt;</span></span><br><span class="line">$&#123;pizza.size&#125;:</span><br><span class="line">    <span class="tag">&lt;<span class="name">c:forEach</span> <span class="attr">items</span>=<span class="string">&quot;$&#123;pizza.toppings&#125;&quot;</span> <span class="attr">var</span>=<span class="string">&quot;topping&quot;</span>&gt;</span>&amp;&amp;$&#123;topping&#125;<span class="tag">&lt;/<span class="name">c:forEach</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">c:forEach</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;$&#123;flowExecutionUrl&#125;&amp;_eventId=createPizza&quot;</span>&gt;</span>Create Pizza<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;$&#123;flowExecutionUrl&#125;&amp;_eventId=checkout&quot;</span>&gt;</span>Checkout<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;$&#123;flowExecutionUrl&#125;&amp;_eventId=cancel&quot;</span>&gt;</span>Cancel<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>添加披萨的视图createPizza如下所示，注意form:form标签可以使用modelAttribute来绑定model对象，这边绑定的是流程传过来的Pizza对象。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">&lt;%@ taglib prefix=&quot;form&quot; uri=&quot;http://www.springframework.org/tags/form&quot; %&gt;</span><br><span class="line">&lt;%--</span><br><span class="line">  Created by IntelliJ IDEA.</span><br><span class="line">  User: Administrator</span><br><span class="line">  Date: 2021/4/5</span><br><span class="line">  Time: 14:20</span><br><span class="line">  To change this template use File | Settings | File Templates.</span><br><span class="line">--%&gt;</span><br><span class="line">&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; isELIgnored=&quot;false&quot; %&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Spizza<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>Create Pizza<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form:form</span> <span class="attr">modelAttribute</span>=<span class="string">&quot;pizza&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;hidden&quot;</span> <span class="attr">name</span>=<span class="string">&quot;_flowExecutionKey&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;flowExecutionKey&#125;&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">b</span>&gt;</span>Size: <span class="tag">&lt;/<span class="name">b</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">form:radiobutton</span> <span class="attr">path</span>=<span class="string">&quot;size&quot;</span> <span class="attr">label</span>=<span class="string">&quot;Small (12-inch)&quot;</span> <span class="attr">value</span>=<span class="string">&quot;SMALL&quot;</span>/&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">form:radiobutton</span> <span class="attr">path</span>=<span class="string">&quot;size&quot;</span> <span class="attr">label</span>=<span class="string">&quot;Medium (14-inch)&quot;</span> <span class="attr">value</span>=<span class="string">&quot;MEDIUM&quot;</span>/&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">form:radiobutton</span> <span class="attr">path</span>=<span class="string">&quot;size&quot;</span> <span class="attr">label</span>=<span class="string">&quot;Large (16-inch)&quot;</span> <span class="attr">value</span>=<span class="string">&quot;LARGE&quot;</span>/&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">form:radiobutton</span> <span class="attr">path</span>=<span class="string">&quot;size&quot;</span> <span class="attr">label</span>=<span class="string">&quot;Ginormous (20-inch)&quot;</span> <span class="attr">value</span>=<span class="string">&quot;GINORMOUS&quot;</span>/&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">b</span>&gt;</span>Toppings: <span class="tag">&lt;/<span class="name">b</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">form:checkboxes</span> <span class="attr">path</span>=<span class="string">&quot;toppings&quot;</span> <span class="attr">items</span>=<span class="string">&quot;$&#123;toppingsList&#125;&quot;</span>/&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">class</span>=<span class="string">&quot;button&quot;</span> <span class="attr">name</span>=<span class="string">&quot;_eventId_addPizza&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Continue&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">class</span>=<span class="string">&quot;button&quot;</span> <span class="attr">name</span>=<span class="string">&quot;_eventId_cancel&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Cancel&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form:form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="takePayment子流程"><a href="#takePayment子流程" class="headerlink" title="takePayment子流程"></a>takePayment子流程</h3><p>takePayment子流程实际上相比buildOrder而言，并没有什么太多的特别之处，这边的视图略过不提，如果你想看完整的代码，可以从Github上下载源码。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">flow</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/webflow&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/webflow</span></span></span><br><span class="line"><span class="tag"><span class="string">      http://www.springframework.org/schema/webflow/spring-webflow-2.0.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">&quot;order&quot;</span> <span class="attr">required</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">view-state</span> <span class="attr">id</span>=<span class="string">&quot;takePayment&quot;</span> <span class="attr">model</span>=<span class="string">&quot;flowScope.paymentDetails&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">on-entry</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">set</span> <span class="attr">name</span>=<span class="string">&quot;flowScope.paymentDetails&quot;</span> <span class="attr">value</span>=<span class="string">&quot;pizzaFlowActions.generatePayment(order)&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">evaluate</span> <span class="attr">expression</span>=<span class="string">&quot;T(org.zh.pizza.domain.PaymentType).asList()&quot;</span> <span class="attr">result</span>=<span class="string">&quot;viewScope.paymentTypeList&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">on-entry</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">transition</span> <span class="attr">on</span>=<span class="string">&quot;paymentSubmitted&quot;</span> <span class="attr">to</span>=<span class="string">&quot;verifyPayment&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">transition</span> <span class="attr">on</span>=<span class="string">&quot;cancel&quot;</span> <span class="attr">to</span>=<span class="string">&quot;cancel&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">view-state</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">action-state</span> <span class="attr">id</span>=<span class="string">&quot;verifyPayment&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">evaluate</span> <span class="attr">expression</span>=<span class="string">&quot;pizzaFlowActions.verifyPayment(flowScope.paymentDetails)&quot;</span></span></span><br><span class="line"><span class="tag">                  <span class="attr">result</span>=<span class="string">&quot;order.payment&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">transition</span> <span class="attr">to</span>=<span class="string">&quot;paymentTaken&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">action-state</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">end-state</span> <span class="attr">id</span>=<span class="string">&quot;cancel&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">end-state</span> <span class="attr">id</span>=<span class="string">&quot;paymentTaken&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">flow</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="运行效果"><a href="#运行效果" class="headerlink" title="运行效果"></a>运行效果</h2><p>进入流程后，第一个看到的页面为welcome.jsp。</p>
<p><img src="2.png" alt="2"></p>
<p>如果没有注册过，进入registrationForm.jsp，注意这里输入的zipCode是会接收检查的。</p>
<p><img src="3.png" alt="3"></p>
<p>若zipCode检查不通过，会进入deliveryWarning.jsp。</p>
<p><img src="4.png" alt="4"></p>
<p>点击第一个超链接，进入showOrder.jsp，一开始没有任何订单，你可以点击Create Pizza来创建披萨，也可以点击Checkout前往支付。</p>
<p><img src="5.png" alt="5"></p>
<p>如果点击Create Pizza，则需要选择披萨尺寸和配料。</p>
<p><img src="6.png" alt="6"></p>
<p>重新回到订单页面，可以看到最新的订单信息已经同步过来了。</p>
<p><img src="7.png" alt="7"></p>
<p>点击支付Checkout，系统会自动计算费用，我们自己要做的仅仅只是勾选支付方式。</p>
<p><img src="8.png" alt="8"></p>
<p>完成整个流程，进入thankCustomer.jsp，点击finish，即可回到首页。</p>
<p><img src="9.png" alt="9"></p>
<p>在这个过程中，点击任意的Cancel按钮，都会触发cancel转移，从而结束整个流程，返回首页。</p>
<h1 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h1><p>可以从这个Github仓库找到上述案例的完整代码。</p>
<p><a href="https://github.com/ZenoXen/pizza-flow-demo">SpringWebFlow案例</a></p>
<h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><p><a href="https://www.manning.com/books/spring-in-action-fourth-edition">Spring实战第四版</a></p>
<p><a href="https://blog.csdn.net/u012562943/article/details/50264845">SpringWebFlow实例教程</a></p>
]]></content>
      <categories>
        <category>Spring</category>
        <category>SpringWebFlow</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>SpringWebFlow</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring与Redis整合</title>
    <url>/2021/03/01/Spring%E4%B8%8ERedis%E6%95%B4%E5%90%88/</url>
    <content><![CDATA[<p>如果你学过Redis，应该知道它是一个键值对的内存数据库应用，一般是作为服务器后端中的数据库或者是缓存来使用（国内大环境下用作缓存更多）。</p>
<h1 id="Redis作为数据库使用"><a href="#Redis作为数据库使用" class="headerlink" title="Redis作为数据库使用"></a>Redis作为数据库使用</h1><p>这里主要介绍两个比较常见的Redis操作库，Jedis和SpringDataRedis</p>
<h2 id="Jedis"><a href="#Jedis" class="headerlink" title="Jedis"></a>Jedis</h2><p>Jedis是一个小巧、简单、易用的Redis client，Java导入Jedis依赖后，可以直接对Redis进行连接，并直接操作各种数据结构。</p>
<p>可以使用下面的pom依赖导入Jedis。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>redis.clients<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jedis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">type</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在Spring环境下，Jedis可以类比成一个JDBC的Connection，你可以通过这个Connection对Redis进行各种操作，那么就很容易写出这样的代码。</p>
<p>首先进行配置，将Jedis配置为Bean，在构造对象时，提供redis的服务器地址和端口号。</p>
<p><img src="1.png" alt="1"></p>
<p>使用的时候，注入Jedis的bean即可，随后就可以通过jedis对象操作redis了。</p>
<p><img src="2.png" alt="2"></p>
<h2 id="SpringDataRedis"><a href="#SpringDataRedis" class="headerlink" title="SpringDataRedis"></a>SpringDataRedis</h2><p>SpringDataRedis是SpringData这个大项目中的一个子项目，与Spring高度集成，是我们在Spring项目中整合Redis的不二之选。</p>
<p>使用SpringDataRedis，我们可以至少可以获得以下好处。</p>
<ol>
<li>自由选择Redis连接器，比如jedis、jredis、lettuce</li>
<li>通过预先配置的RedisTemplate，直接进行Redis操作，免去了创建、释放连接的过程，与JdbcTemplate作用类似</li>
<li>可以自由选择数据序列化的方式</li>
<li>提供了对SpringCache整合Redis的支持，后面会讲到</li>
</ol>
<p>那么Jedis和SpringDataRedis的关系也就明朗了，SpringDataRedis底层使用的是redis client，比如jedis、jredis、lettuce这样的，即SpringDataRedis是对jedis这种连接器的一种封装。</p>
<h3 id="SpringDataRedis的依赖"><a href="#SpringDataRedis的依赖" class="headerlink" title="SpringDataRedis的依赖"></a>SpringDataRedis的依赖</h3><p>SpringDataRedis可以通过以下的SpringBoot起步依赖引入。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>SpringDataRedis的官方文档上介绍的引入方式是这种。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.data<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3.6.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这两种方式有什么不一样？很简单，看一下spring-boot-starter-data-redis是怎么构成的。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3.7.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.data<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3.6.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.lettuce<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lettuce-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.3.5.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>实际上就是spring-boot-starter、spring-data-redis和lettuce-core这三个依赖组成的，同时也可以发现，SpringDataRedis默认使用的是lettuce作为连接器。</p>
<h3 id="SpringDataRedis的使用"><a href="#SpringDataRedis的使用" class="headerlink" title="SpringDataRedis的使用"></a>SpringDataRedis的使用</h3><h4 id="连接到Redis"><a href="#连接到Redis" class="headerlink" title="连接到Redis"></a>连接到Redis</h4><p>与Jedis类似，我们需要提供一个预设的连接配置。在SpringDataRedis中，负责连接到Redis的主要有两个类，RedisConnection和RedisConnectionFactory，从名字就可以看出，我们实际上是对RedisConnectionFactory提供配置，这个Factory根据我们提供的Redis连接配置，生产RedisConnection。</p>
<p>SpringDataRedis默认选择的Redis连接器是Lettuce，这里需要注意一下，虽然Java有多种Redis连接器，但并非所有的连接器都支持Redis的所有特性，具体可以参考SpringDataRedis官方文档的<a href="https://docs.spring.io/spring-data/redis/docs/2.4.6/reference/html/#redis:connectors:connection">连接</a>。</p>
<p>配置一个Lettuce实现的RedisConnectionFactory，如下所示。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RedisConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> LettuceConnectionFactory <span class="title">redisConnectionFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> LettuceConnectionFactory(<span class="keyword">new</span> RedisStandaloneConfiguration(<span class="string">&quot;localhost&quot;</span>, <span class="number">6379</span>));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="使用RedisTemplate"><a href="#使用RedisTemplate" class="headerlink" title="使用RedisTemplate"></a>使用RedisTemplate</h4><p>RedisTemplate是SpringDataRedis的核心组件，它高度封装的特性可以让我们不需要关心序列化的过程而直接将Java数据类型写入Redis。</p>
<p>虽然RedisConnection也可以操作Redis，但相比与RedisTemplate，它们操作数据的层次不一样，RedisConnection提供偏向底层的Redis操作，即直接操作二进制数据；而RedisTemplate处于一个高层的位置，序列化Java对象后调用RedisConnection写入Redis。</p>
<p><img src="3.png" alt="3"></p>
<p>可以看到，上面用了RedisTempalte的opsForValue方法，实际上，它还能使用其他的operation，以下摘自SpringDataRedis官方文档。</p>
<table>
<thead>
<tr>
<th>Operation</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>GeoOperations</code></td>
<td>操作geo类型, 比如<code>GEOADD</code>, <code>GEORADIUS</code></td>
</tr>
<tr>
<td><code>HashOperations</code></td>
<td>操作hash类型</td>
</tr>
<tr>
<td><code>HyperLogLogOperations</code></td>
<td>操作HyperLogLog, 比如<code>PFADD</code>, <code>PFCOUNT</code></td>
</tr>
<tr>
<td><code>ListOperations</code></td>
<td>操作list类型</td>
</tr>
<tr>
<td><code>SetOperations</code></td>
<td>操作set类型</td>
</tr>
<tr>
<td><code>ValueOperations</code></td>
<td>操作一般的键值对类型，即字符串</td>
</tr>
<tr>
<td><code>ZSetOperations</code></td>
<td>操作zset类型</td>
</tr>
</tbody></table>
<p>除了以上这些Operation，为了方便使用，还可以将一个特定的key绑定到Operation上，比如下面这样，如此一来，这个Operation专门就是为mykey这个键进行服务的了。</p>
<p><img src="4.png" alt="4"></p>
<h4 id="RedisTemplate的序列化机制"><a href="#RedisTemplate的序列化机制" class="headerlink" title="RedisTemplate的序列化机制"></a>RedisTemplate的序列化机制</h4><p>使用RedisTemplate时，默认使用的是jdk序列化，即如果你想存一个自定义对象，那么应该让其实现Serializable接口，否则jdk是无法进行序列化的。</p>
<p>如果不想使用SpringBoot预配置的RedisTemplate，那么我们可以自己决定序列化方式。</p>
<p>下面是几种常见的序列化器。</p>
<ul>
<li>JdkSerializationRedisSerializer：基于Jdk的序列化器，RedisTemplate默认使用的</li>
<li>StringRedisSerializer：将key或者value序列化成字符串，存进redis时是人可读的</li>
<li>Jackson2JsonRedisSerializer：将对象序列化为json格式</li>
</ul>
<p>在配置RedisTemplate时，可以自行设置序列化方式。</p>
<p><img src="5.png" alt="5"></p>
<p>上面的例子中，设置了普通的键和hash类型的键使用StringRedisSerializer，普通的value和hash的value使用Jackson2JsonRedisSerializer，上面这个例子中对json序列化过程也进行了一定的定制，即设置ObjectMapper，设置对象映射可见性为所有，其他的取值可以参照下图。</p>
<p><img src="6.png" alt="6"></p>
<p>activateDefaultTyping方法则是设置了序列化过程中，将对象中的所有字段类型也一并作为信息写入。</p>
<p>RedisTemplate的afterPropertiesSet可以不调用，如果对其源码感兴趣可以自行阅读，这里就直接说了，它可以检查RedisTemplate中的key和value的序列化器是否都已设置妥当，若没有设置，则启用默认的序列化器，即Jdk序列化器。</p>
<h3 id="RedisRepository"><a href="#RedisRepository" class="headerlink" title="RedisRepository"></a>RedisRepository</h3><p>如果你接触过SpringDataJPA，那应该知道JPA的持久化套路，主要是以下几步。</p>
<ul>
<li>定义Entity类，即实体类，比如User这样的</li>
<li>定义Repository类，这种可以理解为实体类专属的查询工具，比如UserRepository就是用来对User实体增删改查的</li>
<li>调用Repository类的方法对Entity操作，比如userRepository.save(user)</li>
</ul>
<p>实际上SpringDataRedis也提供了一套这样的持久化方式，相较于直接使用RedisTemplate操作，通过Repository进行操作要简单不少。</p>
<h4 id="定义RedisHash类"><a href="#定义RedisHash类" class="headerlink" title="定义RedisHash类"></a>定义RedisHash类</h4><p>首先，假设我们要将Book类持久化到Redis中，那么这样定义。</p>
<p><img src="7.png" alt="7"></p>
<p>首先需要在Book类上添加@RedisHash注解，作用可以类比为JPA的Entity注解，如此Book类就能以hash数据类型被持久化到Redis中，两个参数分别为key生存时间（单位为秒）和key的前缀。</p>
<p>其次可以看到，属性中有一个id属性，用@Id注解标注，对SpringDataRedis来说，这种id属性是辅助前缀生成key的重要标识，比如上图中的Book类，@RedisHash中的value是book，有一个id属性，那么存储一个Book对象时，产生的redis key就是<strong>book前缀+id</strong>。</p>
<p>注意Book还打上了Serializable接口，这是因为没有更改默认配置，那么默认使用的是Jdk序列化方式，这个前面已经说到过了。</p>
<h4 id="定义Repository类"><a href="#定义Repository类" class="headerlink" title="定义Repository类"></a>定义Repository类</h4><p>随后要定义一个BookRepository，它必须是interface类型，且继承CrudRepository接口。</p>
<p><img src="8.png" alt="8"></p>
<p>从上图可以看到，CrudRepository的泛型声明是由两个类型组成的，第一个Book，即需要持久化的类，第二个类型是id字段的类型，我自定义的Book类中使用的id是String类型，那这里就要写String。</p>
<h4 id="开启RedisRepositories注解"><a href="#开启RedisRepositories注解" class="headerlink" title="开启RedisRepositories注解"></a>开启RedisRepositories注解</h4><p>还需要在SpringBoot启动类或者配置类上加上@EnableRedisRepositories注解，才能开启该功能。</p>
<h4 id="使用RedisRepository"><a href="#使用RedisRepository" class="headerlink" title="使用RedisRepository"></a>使用RedisRepository</h4><p>这里以存储方法为例，直接调用bookRepository的save方法即可，注意id可以不设置，SpringDataRedis会自动产生一个id。</p>
<p><img src="9.png" alt="9"></p>
<h1 id="Redis作为缓存使用"><a href="#Redis作为缓存使用" class="headerlink" title="Redis作为缓存使用"></a>Redis作为缓存使用</h1><p>虽然RedisTemplate和RedisRepository可以让我们将Redis当成内存数据库使用，但国内大环境下，Redis应用环境仍然是缓存比较多，Spring也提供了缓存支持，下面就讲讲Spring的缓存机制以及如何与Redis整合。</p>
<p>如果某个方法特别耗时，或者占用的计算机资源过高，则可以使用缓存注解对这些方法标注，下次再执行这个方法，就不需要从头执行了，只需要从缓存中取出相应的数据。</p>
<h2 id="SpringCache"><a href="#SpringCache" class="headerlink" title="SpringCache"></a>SpringCache</h2><p>Spring提供了几个缓存相关的注解，如下。</p>
<ul>
<li>Cacheable</li>
<li>CacheEvict</li>
<li>CachePut</li>
<li>Caching</li>
</ul>
<p>SpringCache的作用主要是给Java方法提供缓存，即上面这些注解，一般是用在方法上的，在方法触发时，对缓存数据执行相应的操作，比如将方法返回值放进缓存或者删除缓存中的某个数据等等。</p>
<p>以上注解实际上只是一个缓存的抽象，底层究竟如何存储缓存，这就需要引入缓存实现的概念。</p>
<h2 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h2><p>Spring提供了几种缓存实现，比如基于ConcurrentHashMap的缓存、Ehcache、Gemfire、Caffeine。</p>
<p>如果你引入了spring-boot-starter-cache，那么默认使用的是ConcurrentHashMap实现；如果你想使用SpringCache的Redis实现，那么还需要引入spring-boot-starter-data-redis。</p>
<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>如果你的项目引入了spring-boot-starter-data-redis，那么默认的连接属性是连接到localhost的6379端口，可以通过覆盖配置来修改。</p>
<p><img src="10.png" alt="10"></p>
<p>或者也可以直接在application.properties中设置。</p>
<p><img src="11.png" alt="11"></p>
<p>由于序列化Java对象默认使用的Jdk序列化，自定义类需要实现Serializable接口才能进行缓存；如果你想要将其存转换为json格式的数据，需要配置一个Jackson序列化器来覆盖默认的Jdk序列化器，然后将其设置给RedisTemplate。</p>
<p>下面给出我自己现在用的一套RedisTemplate设置，由于我的项目中还需要保存ZonedDateTime，这里也对时间转换进行了一些定制化，你可以根据自己的需要参考。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RedisTemplate&lt;String, Object&gt; <span class="title">redisTemplate</span><span class="params">(RedisConnectionFactory factory)</span> </span>&#123;</span><br><span class="line">        RedisTemplate&lt;String, Object&gt; template = <span class="keyword">new</span> RedisTemplate&lt;&gt;();</span><br><span class="line">        template.setConnectionFactory(factory);</span><br><span class="line"></span><br><span class="line">        StringRedisSerializer stringRedisSerializer = <span class="keyword">new</span> StringRedisSerializer();</span><br><span class="line">        template.setKeySerializer(stringRedisSerializer);</span><br><span class="line">        template.setHashKeySerializer(stringRedisSerializer);</span><br><span class="line"></span><br><span class="line">        Jackson2JsonRedisSerializer&lt;Object&gt; jackson2JsonRedisSerializer = <span class="keyword">new</span> Jackson2JsonRedisSerializer&lt;&gt;(Object.class);</span><br><span class="line">        ObjectMapper om = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line">        om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);</span><br><span class="line">        om.activateDefaultTyping(LaissezFaireSubTypeValidator.instance, ObjectMapper.DefaultTyping.NON_FINAL);</span><br><span class="line">        om.configure(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS, <span class="keyword">false</span>);</span><br><span class="line">        om.registerModule(<span class="keyword">new</span> JavaTimeModule());</span><br><span class="line">        om.disable(DeserializationFeature.ADJUST_DATES_TO_CONTEXT_TIME_ZONE);</span><br><span class="line">        jackson2JsonRedisSerializer.setObjectMapper(om);</span><br><span class="line"></span><br><span class="line">        template.setValueSerializer(jackson2JsonRedisSerializer);</span><br><span class="line">        template.setHashValueSerializer(jackson2JsonRedisSerializer);</span><br><span class="line">        template.afterPropertiesSet();</span><br><span class="line">        <span class="keyword">return</span> template;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>最终还需要开启Spring缓存支持，使用@EnableCaching注解对启动类或者配置类进行标注即可。</p>
<h2 id="缓存注解"><a href="#缓存注解" class="headerlink" title="缓存注解"></a>缓存注解</h2><p>前面在介绍SpringCache的时候就说到了Spring提供的几种缓存注解，即Cacheable、CacheEvict、CachePut、Caching，下面就讲讲这些注解的作用。</p>
<table>
<thead>
<tr>
<th>注解</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>@Cacheable</td>
<td>在方法调用之前，先在缓存中查找对应的值，若不存在，调用方法，将结果放到缓存中；若相应的值存在，直接返回，不执行方法。</td>
</tr>
<tr>
<td>@CachePut</td>
<td>方法执行完成后，将结果存放到对应的缓存中，不会检查是否有对应的缓存，方法始终会执行，是一个单纯的写入注解。</td>
</tr>
<tr>
<td>@CacheEvict</td>
<td>从缓存中清除一个或多个条目。</td>
</tr>
<tr>
<td>@Caching</td>
<td>一个总和性的注解，里面可以包含Cacheable、CachePut、CacheEvict</td>
</tr>
</tbody></table>
<h3 id="写入缓存"><a href="#写入缓存" class="headerlink" title="写入缓存"></a>写入缓存</h3><p>Cacheable和CachePut注解都可以往缓存中存值，但两者执行机制是不同的。</p>
<p>它们的属性类似。</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>类型</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>value</td>
<td>String[]</td>
<td>缓存名称，不同名称的缓存是相互隔离的</td>
</tr>
<tr>
<td>condition</td>
<td>String</td>
<td>Spel表达式，得到false，则缓存对当前方法不生效</td>
</tr>
<tr>
<td>key</td>
<td>String</td>
<td>Spel表达式，计算自定义的缓存key</td>
</tr>
<tr>
<td>unless</td>
<td>String</td>
<td>Spel表达式，如果得到的是true，返回值不会放到缓存中</td>
</tr>
</tbody></table>
<h4 id="自定义key"><a href="#自定义key" class="headerlink" title="自定义key"></a>自定义key</h4><p>当一个方法要把返回值存进缓存中时，是根据key来存的，如果不指定key属性，则使用传给方法的所有的参数来生成key，而如果指定了，则使用自定义的Spel来生成key，Spring向外暴露了一些元数据，使我们可以方便的通过Spel表达式来计算自定义的key。</p>
<table>
<thead>
<tr>
<th>表达式</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>#root.args</td>
<td>传递给缓存方法的参数，为数组</td>
</tr>
<tr>
<td>#root.caches</td>
<td>该方法对应的缓存名，为数组</td>
</tr>
<tr>
<td>#root.target</td>
<td>缓存目标对象</td>
</tr>
<tr>
<td>#root.targetClass</td>
<td>目标对象的类，相当于#root.target.class的简写</td>
</tr>
<tr>
<td>#root.method</td>
<td>缓存方法</td>
</tr>
<tr>
<td>#root.methodName</td>
<td>缓存方法的名字，相当于#root.method.name的简写</td>
</tr>
<tr>
<td>#result</td>
<td>方法调用的返回值（不能用在Cacheable注解上）</td>
</tr>
<tr>
<td>#Argument</td>
<td>任意方法参数名（注意是参数名，不是参数值）</td>
</tr>
</tbody></table>
<p>比如下面这个例子中，我只想用一个参数名来产生缓存，可以这样写。</p>
<p><img src="16.png" alt="16"></p>
<h4 id="条件化缓存"><a href="#条件化缓存" class="headerlink" title="条件化缓存"></a>条件化缓存</h4><p>Cacheable和CachePut注解都有属性condition和unless。</p>
<p>condition：如果Spel表达式计算为true，则检查缓存中是否存在对应的值，存在就返回，不存在就存入；如果为false，直接执行方法，也不会去存入缓存，就跟没设置Cacheable注解一样。</p>
<p>unless: 如果Spel表达式为true，则不会将返回值存入缓存。从这个属性的功能上就可以看出来，unless只是用来阻止写入的，并不能用来阻止读取缓存。</p>
<p>比如下面这个例子，condition为#pageNum&gt;0，即只有当方法参数pageNum&gt;0时，这个缓存生效;unless为#name==null，即，只要方法参数name为null，就不写入缓存。如果name为null并且pageNum大于0，是不写入缓存的；如果name不为null，但pageNum小于等于0，那么也不会写入缓存。</p>
<p><img src="17.png" alt="17"></p>
<h4 id="关于缓存名称"><a href="#关于缓存名称" class="headerlink" title="关于缓存名称"></a>关于缓存名称</h4><p>不同缓存名称之间是相互隔离的，比如下面这个例子中，两个方法除了cacheNames其他属性完全一样。</p>
<p><img src="12.png" alt="12"></p>
<p>这里给出bookRepository的实现，它实际上并不是个JPA查询，只是简单的返回一个new出来的对象，可以预测的是，如果缓存命中了，那么应该输出”执行了数据库查询”。</p>
<p><img src="13.png" alt="13"></p>
<p>调用第一个方法，结果如下，说明第一次缓存没有命中，cacheManager往缓存中存入了Book对象。</p>
<p><img src="14.png" alt="14"></p>
<p>再次访问第一个方法，发现没有输出，说明缓存命中。</p>
<p>调用第二个方法，提供的参数完全与前面一致，发现输出了一次，说明没有命中，此时验证成功–不同name的缓存确实是相互隔离的。</p>
<p><img src="15.png" alt="15"></p>
<h3 id="移除缓存条目"><a href="#移除缓存条目" class="headerlink" title="移除缓存条目"></a>移除缓存条目</h3><p>使用CacheEvict可以从某个缓存中移除一条或多条数据。</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>类型</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>value</td>
<td>String[]</td>
<td>缓存名称</td>
</tr>
<tr>
<td>key</td>
<td>String</td>
<td>Spel表达式，计算自定义key</td>
</tr>
<tr>
<td>condition</td>
<td>String</td>
<td>Spel表达式，如果是false,则该方法不会应用缓存</td>
</tr>
<tr>
<td>allEntries</td>
<td>boolean</td>
<td>如果为true，则删除该缓存的所有条目</td>
</tr>
<tr>
<td>beforeInvocation</td>
<td>boolean</td>
<td>如果为true，在方法调用之前移除key；如果为fasle，则方法调用后移除key</td>
</tr>
</tbody></table>
<h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><p><a href="">spring-data-redis官方文档</a></p>
<p><a href="https://docs.spring.io/spring-boot/docs/2.3.7.RELEASE/reference/htmlsingle/#boot-features-caching">spring-boot官方文档–caching</a></p>
<p><a href="https://docs.spring.io/spring-framework/docs/current/reference/html/integration.html#cache">spring-framework官方文档–cache abstraction</a></p>
<p><a href="https://blog.csdn.net/houpeibin2012/article/details/104364826">spring-data-redis与jedis的区别</a></p>
]]></content>
      <categories>
        <category>Spring</category>
        <category>Cache</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>缓存</tag>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring实现手机号脱敏处理</title>
    <url>/2021/04/20/Spring%E5%AE%9E%E7%8E%B0%E6%89%8B%E6%9C%BA%E5%8F%B7%E8%84%B1%E6%95%8F%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>先介绍一下我这边的开发场景，数据库中存的是完整的手机号，即没有加密过的字符串，但需求希望将数据返回前端时进行脱敏处理，将手机号中间4位替换为*号。</p>
<p>这里还有一点值得一提，返回的ResponseBody中，可能存在一些手机号是夹杂在一个字符串中间的，需要在保留字符串原来内容的前提下，对这些手机号进行脱敏处理。</p>
<h1 id="正则表达式实现数据脱敏"><a href="#正则表达式实现数据脱敏" class="headerlink" title="正则表达式实现数据脱敏"></a>正则表达式实现数据脱敏</h1><p>实现这个功能的思路是，使用正则表达式替换一个字符串中的所有符合手机号码特征的子串，Java的String类本身就提供了replaceAll方法，我们可以用该方法实现这个功能。</p>
<p>首先来看看匹配手机号码的正则和手机模糊化的正则。</p>
<h2 id="中国手机号码的结构特征"><a href="#中国手机号码的结构特征" class="headerlink" title="中国手机号码的结构特征"></a>中国手机号码的结构特征</h2><p>一般中国的手机号码是11位，前三位是根据运营商而定的，4到7位为地区编码，8到11位是随机分配给用户的号码，一般加密是给中间四位地区码加密。</p>
<p>同时前三位手机号，第一位就是1，第二位和第三位各个运营商各有不同，基本规律我写在下面的代码中，即3可以组合0-9，4组合5或7，5组合0-3或5-9……</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String PHONE_REGEX = <span class="string">&quot;1(3[0-9]|4[57]|5[0-35-9]|7[0135678]|8[0-9])\\d&#123;4&#125;(\\d&#123;4&#125;)&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String PHONE_BLUR_REGEX = <span class="string">&quot;1$1****$2&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>而将中间四位替换为星号的话，需要在正则表达式中使用圆括号划分出两个区域，即第二和第三位与最后四位之间的位置。</p>
<h1 id="自定义ResponseBody数据转换"><a href="#自定义ResponseBody数据转换" class="headerlink" title="自定义ResponseBody数据转换"></a>自定义ResponseBody数据转换</h1><p>一般来说，在我们的系统中并不是所有地方都必须得将手机号进行脱敏，有些地方可能还是需要将手机号暴露给用户的，对于不同的接口或者说对于不同的ResponseBody，可以使用Jackson的序列化器来指定如何将JSON序列化给前端。</p>
<h2 id="自定义JsonSerializer"><a href="#自定义JsonSerializer" class="headerlink" title="自定义JsonSerializer"></a>自定义JsonSerializer</h2><p>自定义一个DesensitizeSerializer，继承JsonSerializer&lt;String&gt;，即它是用于字符串的序列化，在方法中直接调用String的replaceAll方法，将所有符合PHONE_REGEX的字串使用PHONE_BLUR_REGEX替换为加密过的字符串。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DesensitizeSerializer</span> <span class="keyword">extends</span> <span class="title">JsonSerializer</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String PHONE_REGEX = <span class="string">&quot;1(3[0-9]|4[57]|5[0-35-9]|7[0135678]|8[0-9])\\d&#123;4&#125;(\\d&#123;4&#125;)&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String PHONE_BLUR_REGEX = <span class="string">&quot;1$1****$2&quot;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">serialize</span><span class="params">(String s, JsonGenerator jsonGenerator, SerializerProvider serializerProvider)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        jsonGenerator.writeString(<span class="keyword">this</span>.encryptPhoneNumber(s));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">encryptPhoneNumber</span><span class="params">(String phoneNumber)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(Objects.nonNull(phoneNumber)) &#123;</span><br><span class="line">            <span class="keyword">return</span> phoneNumber.replaceAll(PHONE_REGEX, PHONE_BLUR_REGEX);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="应用JsonSerializer"><a href="#应用JsonSerializer" class="headerlink" title="应用JsonSerializer"></a>应用JsonSerializer</h2><p>一般我们使用ResponseBody注解将一个Pojo类或者JPA的interface-based projection返回给前端，虽然我们的确可以在SQL层面做预处理，但那样就容易受需求变更的影响了，而如果是在返回给前端的最后一步之前，也就是将ResponseBody序列化为Json的这一步做处理，那么就很容易面临需求的变更了。</p>
<p>假设现在有个UserAccount类作为ResponseBody返回给前端，其中的mobile字段需要加密，我们可以像下面这样应用之前写好的JsonSerializer。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserAccount</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@JsonSerialize(using = DesensitizeSerializer.class)</span></span><br><span class="line">    <span class="keyword">private</span> String mobile;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>@JsonSerialize注解可以用在getter方法上或者是类字段上，使用using属性可以为这个字段指定一个JsonSerializer。</p>
<p>写一个测试接口，来看看结果。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;<span class="attr">&quot;mobile&quot;</span>:<span class="string">&quot;135****3843&quot;</span>&#125;</span><br></pre></td></tr></table></figure>

<p>如果手机号是混杂在一个很长的字符串里的，也不必担心，String的replaceAll方法可以将整个字符串中所有的手机号加密。</p>
<h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><p><a href="https://www.pianshen.com/article/7263153515/">手机号校验与脱敏处理</a></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>Java</tag>
        <tag>信息脱敏</tag>
        <tag>正则表达式</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo博客的定制化</title>
    <url>/2021/02/14/hexo%E5%8D%9A%E5%AE%A2%E7%9A%84%E5%AE%9A%E5%88%B6%E5%8C%96/</url>
    <content><![CDATA[<h1 id="前文"><a href="#前文" class="headerlink" title="前文"></a>前文</h1><p>如果你已经看过我之前写的几篇文章，相信已经对Hexo有了一定了解了，包括怎么安装新主题、配置、部署、发文等，实际上这样对大多数人已经足够了，但你可能不满足于默认的几个功能，比如你还想加入评论、阅读量统计，或者改一下页面布局，这都没问题。</p>
<h1 id="两个配置文件"><a href="#两个配置文件" class="headerlink" title="两个配置文件"></a>两个配置文件</h1><p>相信你已经发现了，hexo有两份配置文件同时生效，一是<strong>hexo全局配置文件</strong>即_config.yml，二是<strong>主题配置文件</strong>，比如我用的是next主题，那么它就是themes/next/_config.yml，定制化主要依靠这两个文件来进行，尤其是主题配置文件，大多数hexo主题其实已经高度集成了许多功能，比如next主题就集成了valine评论插件，可以直接通过主题配置文件打开。</p>
<h1 id="按需阅读"><a href="#按需阅读" class="headerlink" title="按需阅读"></a>按需阅读</h1><p>接下来就说一下，目前我的博客是怎么配置的，你可以根据自己的需求自行食用。</p>
<hr>
<h1 id="修改语言和时区"><a href="#修改语言和时区" class="headerlink" title="修改语言和时区"></a>修改语言和时区</h1><p>在全局配置文件中，language配置项，简体中文是zh-Hans；时区是timezone，中国地区可以修改为Asia/Shanghai</p>
<h1 id="去除页脚Powered和Theme"><a href="#去除页脚Powered和Theme" class="headerlink" title="去除页脚Powered和Theme"></a>去除页脚Powered和Theme</h1><p>一般在主题配置文件中，找到footer配置项，其中包含powered配置项，修改为false，theme.enabled修改为false，theme.version修改为false。<br><img src="footer.png" alt="footer"></p>
<h1 id="修改页面布局"><a href="#修改页面布局" class="headerlink" title="修改页面布局"></a>修改页面布局</h1><p>以next主题为例，一共有四种布局，Muse（默认）、Mist、Pisces（我在用的）、Gemini。<br>修改主题配置文件的scheme项，修改为你想要的布局，比如修改为Pisces，即scheme: Pisces</p>
<h1 id="添加菜单选项"><a href="#添加菜单选项" class="headerlink" title="添加菜单选项"></a>添加菜单选项</h1><p>next主题默认只有home和archive两个选项，如何添加<strong>作者</strong>、<strong>标签</strong>、<strong>分类</strong>这样的页面呢。<br><img src="menu.png" alt="menu"><br>如上图所示，修改menu项，将tags、about、categories前面的<strong>井号</strong>去掉。<br>如此一来，博客菜单栏会展示出这些按钮，但你点击这些按钮时，会发现超链接是无效的，大概率会出现这样的一串玩意。<br><img src="url-error.png" alt="url-error"><br>实际上是因为menu项里url配置不对导致的，你可以仔细看看上面的menu配置项，是不是发现所有路径中间都有一对||符号，实际上，符号左边是菜单项的url，右边是菜单项的图标，next主题的菜单用的是<a href="http://www.fontawesome.com.cn/faicons/">font-awesome</a>图标，你可以参考font-awesome的图标名称随意更改，这里不展开说。这一对||符号左边右边都有一个空格，把这两个空格去掉，即可使菜单url恢复正常。<br>修改完url后再打开发现菜单url还是打不开，这是因为hexo默认就是不包含这些页面的，你需要自己生成。<br>执行下面的代码。<br><code>hexo new page &quot;about&quot;</code><br><code>hexo new page &quot;categories&quot;</code><br><code>hexo new page &quot;tags&quot;</code><br>随后修改source/about/index.md即可，它是完全遵守markdown语法的，categories和tags则不需要修改。</p>
<h1 id="作者头像"><a href="#作者头像" class="headerlink" title="作者头像"></a>作者头像</h1><p>将你想要设置的头像图片放到source/uploads（自建目录）里，重命名为avatar.png。<br>修改主题配置文件中avatar项，比如这样avatar: /uploads/avatar.png。<br><em>注：如果你项用URI的形式也是可以的，不一定非要用本地图片。</em></p>
<h1 id="开启评论和阅读量功能"><a href="#开启评论和阅读量功能" class="headerlink" title="开启评论和阅读量功能"></a>开启评论和阅读量功能</h1><p>在开启这两个功能之前，需要你注册一个LeanCloud的账号（免费注册，不需要充值），这里注册步骤不展开说了，详细说说LeanCloud需要做些什么。<br>首先创建应用，这里应用名称和应用描述随便选一下就可以了，方案选开发版即可，不收费。<br><img src="create-app.png" alt="create-app"><br>随后进入应用管理界面，选择<strong>存储</strong>-&gt;<strong>结构化数据</strong>，其中以下划线开头的这些Class是默认自带的，不用管他们。<br><img src="create-var.png" alt="create-var"><br>我们创建一下两个Class，一个叫Comment一个叫Counter，注意访问权限需要选择<strong>无限制</strong>。<br><img src="comment.png" alt="comment"><br>此时，你可以去应用的设置界面找一下两个关键的东西，即AppId和AppKey，后续会需要这两个字符串。<br><img src="app.png" alt="app"><br>编辑主题配置文件，找到leancloud_visitors项，enabled改为true，app_id和app_key修改为自己的就可以了，这是阅读量统计。<br><img src="leancloud-visitors.png" alt="leancloud-visitors"><br>找到valine项，这是评论功能，enabled改为true，appid和appkey改成自己的，placeholder是评论未输入时的默认占位符，guest_info是评论者需要输入的信息，默认nick、mail、link代表昵称、邮箱地址、个人站点，可以按照你自己的需要删减。<br><img src="valine.png" alt="valine"></p>
<hr>
<h1 id="后文"><a href="#后文" class="headerlink" title="后文"></a>后文</h1><p>以上内容都只是hexo和next配置的一小部分，我只是单纯把一些比较直观的地方捡出来说了，其他配置项你也可以自行探索，可以参考hexo官方文档也可以参考next官方文档，我都在参考文章那部分列出来了。到此为止，hexo博客系列的文章就告一段落了，如果今后我有发现有什么有趣的东西，也许会再更新，大家对这几篇文章有什么建议都可以在评论区告诉我。</p>
<h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><p><a href="https://github.com/iissnan/hexo-theme-next/wiki">github.com/iissnan/hexo-theme-next/wiki</a><br><a href="http://theme-next.iissnan.com/getting-started.html">NexT主题官方起步指南</a><br><a href="https://blog.csdn.net/fullbug/article/details/103844424">解决Hexo博客导航栏链接URL乱码问题</a><br><a href="https://notes.doublemine.me/2015-10-21-%E4%B8%BANexT%E4%B8%BB%E9%A2%98%E6%B7%BB%E5%8A%A0%E6%96%87%E7%AB%A0%E9%98%85%E8%AF%BB%E9%87%8F%E7%BB%9F%E8%AE%A1%E5%8A%9F%E8%83%BD.html#%E9%85%8D%E7%BD%AELeanCloud">为NexT主题添加文章阅读量统计功能</a></p>
]]></content>
      <categories>
        <category>Hexo博客系列</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo如何发布博客</title>
    <url>/2021/02/11/hexo%E5%A6%82%E4%BD%95%E5%8F%91%E5%B8%83%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<h1 id="前文"><a href="#前文" class="headerlink" title="前文"></a>前文</h1><p>搭建Hexo完成后，如何发表一篇文章呢，要知道Hexo生成的博客是不需要数据库与专门的服务器来使用的，所以实际上发表文章用的是静态文件，Hexo使用markdown来生成页面，所以这里建议你先了解一些简单的markdown语法，学习难度不高，而且实用、优雅，不管你是不是程序员都可以学习一下。</p>
<h1 id="生成文章"><a href="#生成文章" class="headerlink" title="生成文章"></a>生成文章</h1><p>这里我们主要用到Hexo的指令<code>hexo new [layout] &lt;articleName&gt;</code>。<br>其中layout可选，默认值是post，其他两种取值是page和draft，articleName是文章名称，必填。这里假设我们不输入layout，也就是使用默认的post布局，执行以上命令后，在项目的source/_posts目录会产生一个md文件，这就是我们的文章主体，直接使用记事本或者md编辑器对其进行编辑即可。<br>接下来看看文章的md文件吧，打开刚生成source/_posts目录下的md文件，一般可以看到文件头上有这些东西。<br><img src="how_to_write.png" alt="how_to_write"><br>这些字段叫做front-matter，可以理解为文章的基本信息，比如title就是文章标题，date为发布日期，tags为文章标签，其他字段具体有什么作用可以参考<a href="https://hexo.io/zh-cn/docs/front-matter">hexo官方文档</a>。设置好这些front-matter后，就可以使用markdown语法来写自己的文章了，除了插入图片会稍微麻烦点。</p>
<h1 id="插入图片"><a href="#插入图片" class="headerlink" title="插入图片"></a>插入图片</h1><p>我们虽然可以用cdn的形式让markdown去引用网上的图片，但效率会比较低，而默认情况下hexo的文章生成时是没法引用静态图片的。<br>为了插入图片，先在项目根目录下安装一个插件。<br><code>npm install hexo-asset-image --save</code><br>随后打开hexo主配置文件_config.yml,找到post_asset_folder项，将其改为true。<br><img src="configure.png" alt="configure"><br>改完后保存退出，下一次你使用hexo new来生成文章时，source/_posts目录里就会多一个目录，它的名字与你的文章一样。<br><img src="folder.png" alt="folder"><br>你可以在这个目录里存放当前文章的图片，在写文章时，只需要像下面这样进行引用就行了。<br><img src="insert_image.png" alt="insert_image"></p>
<h1 id="hexo-clean命令"><a href="#hexo-clean命令" class="headerlink" title="hexo clean命令"></a>hexo clean命令</h1><p>你可能注意到，第一次执行了hexo g后，项目目录下多了一个public目录，这其实是hexo将md文件转换为html文件的结果，部署到Github Pages时，使用的也是public目录的内容。<br>如果你删除了一些以前的文章，重新执行hexo g &amp;&amp; hexo s，结果发现这些文章仍然还在，这是因为hexo每次generate都是追加元素的，并不是覆盖掉public目录。<br>所以如果你想每次部署服务时，都使用当前最新的source目录来生成public，那么应该使用下面这条命令。<br><code>hexo clean</code><br>它可以删除public目录，与其他的命令一起用的话，可以这样。<br><code>hexo clean &amp;&amp; hexo generate &amp;&amp; hexo server</code><br>其中hexo server可以替换成hexo deploy。</p>
<h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><p><a href="https://www.jianshu.com/p/f72aaad7b852">HEXO插入图片（详细版）</a><br><a href="https://hexo.io/zh-cn/docs/">hexo官方文档</a></p>
]]></content>
      <categories>
        <category>Hexo博客系列</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>一些个人老项目的汇总</title>
    <url>/2021/03/01/%E4%B8%80%E4%BA%9B%E4%B8%AA%E4%BA%BA%E8%80%81%E9%A1%B9%E7%9B%AE%E7%9A%84%E6%B1%87%E6%80%BB/</url>
    <content><![CDATA[<p>最近我往我的Github仓库上传了几个项目，都是之前学Java时做的小项目，虽然代码质量不高，但算是我学习Java路上几个不同阶段的标志吧，传到Github的目的是为了做一个历史代码的保存，毕竟Github相对于自己的硬盘来说还是相对稳定的。</p>
<h1 id="基于Swing的局域网聊天软件"><a href="#基于Swing的局域网聊天软件" class="headerlink" title="基于Swing的局域网聊天软件"></a>基于Swing的局域网聊天软件</h1><p>算是我做的第一个Java项目吧（如果那玩意能称为项目的话），实际上可以当作一个小Demo，当时学了Java的io、socket以后，迫切想要实践一下，那时候还不会做前端，所以用了我当时唯一会的客户端技术–Swing，就放两张图片感受一下。</p>
<h2 id="打开软件要求输入聊天昵称"><a href="#打开软件要求输入聊天昵称" class="headerlink" title="打开软件要求输入聊天昵称"></a>打开软件要求输入聊天昵称</h2><p><img src="1.png" alt="1"></p>
<h2 id="聊天界面"><a href="#聊天界面" class="headerlink" title="聊天界面"></a>聊天界面</h2><p><img src="2.png" alt="2"></p>
<p>就这么简单，两张图就完全概括了这软件全部的功能。</p>
<ol>
<li>右边这一列空白我称之为上下线通报，当局域网内有一台主机运行了这个jar包，会发一个广播消息，其他的客户端列表上会显示上线的用户。</li>
<li>中间三个按钮，发送消息也可以用CTRL+回车代替；清屏就是把消息列表清掉；发送文件这玩意我觉得反而是这demo的主要功能…</li>
<li>发送文件时，局域网内至少要有两个在线的用户，其中一个人选择发送文件。</li>
</ol>
<p><img src="3.png" alt="3"></p>
<p>由于我这边没有其他人在用，所以显示了个空白列表，操作也相当简单，当时还做了个进度条…那时候连MVC都没有学，我这套代码里的MVC是我自己脑补出来的…不过跟真正的MVC其实也是一个道理吧。</p>
<h1 id="基于Servlet的个人网盘"><a href="#基于Servlet的个人网盘" class="headerlink" title="基于Servlet的个人网盘"></a>基于Servlet的个人网盘</h1><p>学了JSP+Servlet那一套以后，突然想到做这个东西练手，界面就不放出来了，简直惨不忍睹…那时候还是初学网页这一套技术，连js都不会，让我写个html+css简直要我命，所以我就去网上到处找相关的页面，比如要做注册功能，就去网上找注册页面的模板，要做网盘主页，就去找开源的网盘系统，扒出里面的页面源码；总之到最后究竟缝合了多少个页面我自己都记不清了，现在也没法考究了。</p>
<p>主要功能的话就是注册-&gt;上传文件-&gt;下载文件，上传和下载用的是apache-commons那一套，专门做了个上传进度条，依稀记得用的是ajax，而且这ajax还是网上抄的…</p>
<p>总之最后做出来的东西就是可以用，但没必要用…</p>
<h1 id="图书馆选座系统"><a href="#图书馆选座系统" class="headerlink" title="图书馆选座系统"></a>图书馆选座系统</h1><p>这算是我学完SSM后做的第一个练手小项目，算是第一次实践了前后端分离吧，前端页面也是缝合怪，但样式相比个人网盘来说好了不少，放一张图感受一下。</p>
<p><img src="4.png" alt="4"></p>
<p>总共两个模块，上图这个模块就是普通用户的选座模块，其实功能极其简单…</p>
<p><img src="5.png" alt="5"></p>
<p>第二个模块就是管理模块，可以对各种数据进行管理，其实其他功能都是扯淡，也就楼层管理和选座是主要功能，然而也不是我自己做的…</p>
<p>其实这个选座模块的原理是这样的，有一个Floor表和一个Seat表，Floor表保存了这个楼层的座位的排数和列数，Seat表则保存一个座位的状态，一个座位有四个重要的属性：楼层号、排号、列号、选座状态，也就是说Floor对Seat表是一对多。</p>
<p>初始化选座页面的时候，列出所有可用楼层，点击查看后，根据楼层的排数、列数去初始化一个座位矩阵，然后根据每个座位的选座状态决定是否要显示、显示成什么样，总共就这几种状态：不可用、可选、已预约、已使用，不同状态图标都是不一样的。</p>
<p>可以在管理系统中添加新的楼层，初始化一个排数、列数，点击一下对应座位的图标，就可以把它禁用掉，以此达到自定义座位布局的效果。</p>
<p><img src="6.png" alt="6"></p>
<h1 id="后话"><a href="#后话" class="headerlink" title="后话"></a>后话</h1><p>这几个项目当初写完其实就产生了重构的想法，然而最初写的时候根本都没用过版本管理，现在代码比较杂，尤其是那个Swing项目，代码已经乱到我看都不想看…与其重构，还不如重写来的方便。</p>
<p>这几个项目传到Github上的目的就是留一个怀念，以后想看看曾经写的项目，还可以下过来在本地玩玩。</p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>个人近期状态分析和总结</title>
    <url>/2021/07/04/%E4%B8%AA%E4%BA%BA%E8%BF%91%E6%9C%9F%E7%8A%B6%E6%80%81%E5%88%86%E6%9E%90%E5%92%8C%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>从2020年11月入职新工作到现在，已经半年多了，中间其实并没有发生什么特别的事，生活可谓一潭死水，但也正是如此，我才决定写这篇博客，因为如果再这样下去，我将离我最初的设想越来越远。</p>
<h1 id="近期在干什么"><a href="#近期在干什么" class="headerlink" title="近期在干什么"></a>近期在干什么</h1><p>最近这一个月以来，主要是在忙工作上的事。自从几个月之前，负责平台发票模块的同事离职以后，这一块功能一直没人维护，公司在这方面也没有什么太多需求，前几周的时候得知，发票这部分的功能会有一批新需求，其他的后端同事基本手头都有些任务，于是顺理就指派给我了。</p>
<p>发票模块的功能、代码我之前完全没有接触过，所以是一个全新的挑战，不过好歹也在这家公司待了半年有余，主动联系了一下离职的同事，问了一些需要注意的地方（虽然后来就完全自己看代码，再也没问过了），就开始读代码了。</p>
<p>几个新功能开发用了我10天左右的时间，第一天主要是了解发票功能是怎么跟第三方对接的（我们平台的发票模块是跟一个专业的开票平台对接的），微服务+web service+xml格式的数据传输，这部分技术我不是特别熟，尤其是web service，是我第一次接触。跟三方平台对接的时候，对方给的是一个wsdl地址，并给了个测试账号。</p>
<p>经过我一下午的研究，下载了一个apache cxf，把对方给我的wsdl生成了一系列Java类，如此，就可以通过生成的类来访问对方的wsdl接口。他们的完全使用xml传输数据，跟现在常用的json还是有一点差别的，真正传输之前，需要登录对方的设备，相当于是鉴权，用的是他们给的测试账号，拿到的response是一个loginKey，所有后续业务都需要附带这个loginKey。</p>
<p>request和response都是xml数据，我们这边之前用的是jabx库，可以将Java类与xml之间进行相互转换，在这个过程中还需要按照对方的要求进行3des加密，并最后用Base64编码将数据进行转换。</p>
<p>10天的开发，大约到6月22日左右才上线这几个新功能，但bug可谓层出不穷，有我的责任也有别人的责任，总之6月22日到7月1日之前的这段时间，是我最焦头烂额的，疯狂出现各种exception和性能问题，一直在提交各种merge request和hotfix，上周的时候才算真正修复完毕。</p>
<h1 id="颓废的生活"><a href="#颓废的生活" class="headerlink" title="颓废的生活"></a>颓废的生活</h1><p>忙工作的这段时间，我基本每天熬夜到两三点，其实真正的工作最晚也只到十一点，剩下的时间基本都是躺在床上玩手机，晚上回家前还基本都会路边买一份炒饭。</p>
<p>第二天大概8点40起床去公司，基本都是9点30前后到工位，早餐也没怎么吃。这段时间工作特别没精神，脑子也转不动，实际上就是熬夜导致的，熬夜+不运动差不多算是我这半年以来头号问题了，虽然最近没测体重，但我认为应该比过年那段时间重了不止几公斤了吧…</p>
<p>除了熬夜外，最近这两周还报复性的打游戏，这也算我熬夜主要干的事情之一，直到昨天打开游戏发现怎么玩也没兴趣了以后，终于卸载了游戏，准备重新整顿一下，开始调剂一下生活。</p>
<p>学习也荒废了至少一个多月吧，我知道忙工作并不能成为不学习的理由，但最终还是荒废了。打算下周开始重头学习一下Elasticsearch，这也算后面一段时间工作的学习重点；Leetcode实际上从过年以后一直有在刷，并且时间允许的情况下一直会去报名参与周赛，但实际上我主要是为了5400积分的棒球帽…</p>
<p><img src="1.jpg" alt="1"></p>
<p>本来是想久违地发个朋友圈，但当我带上这帽子以后，感觉自己实在是丑的不行，虽然帽子本身还是不错的，于是作罢…</p>
<p><img src="2.png" alt="2"></p>
<p>所以实际上我前几个月从刷题中收获到的东西实际上非常有限，一直在学习dp，并且找了不少的题做，但到目前为止，面对各种类型的dp仍然没有思路。而且自从拿到帽子后，我也基本就没有再刷过题了，说实话，我还是继续想保持这个习惯的，即使不再是每日三题了，每日只刷一题其实也足够了，最重要的是算法要有个日积月累的过程。</p>
<h1 id="近期规划"><a href="#近期规划" class="headerlink" title="近期规划"></a>近期规划</h1><p>分为学习方面和生活方面说一下近期的规划吧。</p>
<h2 id="学习方面"><a href="#学习方面" class="headerlink" title="学习方面"></a>学习方面</h2><p>如上面所说，学习方面也不打算开太多新坑，主要分为三方面吧。</p>
<ol>
<li>继续维护技术博客，后续还会写一些技术博客，但应该不会发那些自己已经比较了解的技术，而主要是自己不怎么熟的技术。</li>
<li>继续保持刷题的习惯，Leetcode从本科一年级到现在做了大概400多题吧，实际上都是刷几题停一段时间，而且根本没怎么做过笔记、总结，所以实际上从刷题中有效学到的东西非常少，接下来应该重点学一下怎么总结学到的算法。</li>
<li>重点学习各种中间件，我目前的公司项目中，实际上用到各种中间件比较少，但最近一些新的需求导致我们将要开始用它们了，包括消息队列、Spring Cloud Stream、Spring Batch等。</li>
</ol>
<h2 id="生活方面"><a href="#生活方面" class="headerlink" title="生活方面"></a>生活方面</h2><p>生活方面就两件事。</p>
<ol>
<li>早睡，连续几个月的熬夜我感觉是一个定时炸弹，不知道哪天，也许身体就垮了，况且熬夜已经严重影响我的工作状态了，这必须是第一个要解决的问题。</li>
<li>运动，我现在不少问题都是由不运动引发的，想要改善自己的精神面貌，除了早睡就得运动，正好最近我哥推介给我一个健身房连锁店，我觉得还不错，打算过几天去看一下。</li>
</ol>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>我不想日后回忆起自己刚毕业那段时间的时候，总是这样一幅颓废的景象，即使现在天天从网络上接收到的都是负能量，但我还是希望自己不要活成自己最讨厌的样子，引用一下自己过去某段时间的座右铭，“Make a change”，即使很难，但仍要尝试改变现状。</p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>使用Github和Hexo搭建个人博客</title>
    <url>/2021/02/10/%E4%BD%BF%E7%94%A8Github%E5%92%8CHexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<h1 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h1><ol>
<li>安装Git</li>
<li>安装Node.js</li>
<li>注册一个Github账号</li>
</ol>
<hr>
<h1 id="搭建思路"><a href="#搭建思路" class="headerlink" title="搭建思路"></a>搭建思路</h1><p>本文介绍的个人博客属于静态页面，不需要自己管理数据库或者服务器。部署服务是Github的一个福利Github Pages提供的，博客页面使用基于Node.js的一个框架Hexo生成。在继续往下阅读之前，你需要先知道Git和Github怎么用，这里不详细展开这些内容。</p>
<h1 id="Github-Pages"><a href="#Github-Pages" class="headerlink" title="Github Pages"></a>Github Pages</h1><p>Github提供的一个服务，创建一个指定名称的Github仓库，向其中上传html代码，Github会自动为用户部署这些内容，非常方便。但Github Pages都是一些静态页面，即不连接数据库，所有的页面内容都是静态的html、js（包括博客文章也是）。每个Github用户可以拥有一个以用户名为前缀的Github Page，也可以拥有无限个以项目为单位的Github Page。</p>
<p>本文后续搭建的博客使用的是用户名为前缀的Github Page。</p>
<h1 id="Hexo"><a href="#Hexo" class="headerlink" title="Hexo"></a>Hexo</h1><p>Hexo是一个基于Node.js的博客页面生成框架，用户只需要通过yml格式的配置文件进行配置，就可以对博客页面进行个性化的定制，由于作者是台湾人，所以这个框架对中文的支持很好，官方的中文文档也很详细，易于上手。</p>
<p>Hexo有多款主题，如果想要让博客焕然一新，只需要从Github上找一个自己喜欢的主题并安装到自己的项目目录里，少量配置后即可切换主题。</p>
<p>此外Hexo的扩展性也非常好，如果想要对自己的博客功能进行扩展（比如加一个评论功能），可以下载相应的插件并集成到项目中。</p>
<h1 id="搭建步骤"><a href="#搭建步骤" class="headerlink" title="搭建步骤"></a>搭建步骤</h1><p>首先让我们能够在本地把项目跑起来看看效果吧。</p>
<h2 id="安装Node-js"><a href="#安装Node-js" class="headerlink" title="安装Node.js"></a>安装Node.js</h2><p>从<a href="https://nodejs.org/zh-cn/">Node中文官网</a>下载即可，安装过程就不详细介绍了，这里主要讲一讲怎么让Node.js使用国内的淘宝镜像，因为我们后续的许多操作都需要通过Node.js来下载相应的js依赖，而默认的镜像是国外的，下载实在太慢。</p>
<p>在cmd中使用下列命令。</p>
<p><code>npm config set registry https://registry.npm.taobao.org</code></p>
<p>完成后我们的npm命令就会从淘宝镜像下载js依赖。</p>
<h2 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h2><p><code>npm install -g hexo-cli</code></p>
<p>安装完hexo-cli后，我们就可以使用hexo的专用命令很方便的生成博客页面了。</p>
<h2 id="生成Hexo项目"><a href="#生成Hexo项目" class="headerlink" title="生成Hexo项目"></a>生成Hexo项目</h2><p><code>hexo init &lt;folder&gt;</code></p>
<p>其中folder是目录名称，如果不填的话，则所有项目文件默认生成到当前目录。</p>
<p>随后进入生成的项目根目录，使用以下指令安装js依赖。</p>
<p><code>npm install</code></p>
<p>生成后可以查看目录，几个比较重要的文件合目录如下：</p>
<ol>
<li>_config.yml，hexo的全局配置文件</li>
<li>source目录，用于存放静态页面内容，比如html、js、图片之类的</li>
<li>themes，用于存放hexo主题，下载过来的新主题可以放到这个目录下</li>
</ol>
<h2 id="试运行"><a href="#试运行" class="headerlink" title="试运行"></a>试运行</h2><p>此时即使不进行其他配置，Hexo博客也可以运行了，连续使用两条命令。</p>
<p><code>hexo generate</code>（可缩写为hexo g）</p>
<p><code>hexo server</code>（可缩写为hexo s）</p>
<p>此时去访问localhost:4000应该就能看到Hexo的默认页面效果，一般来说是下面这样的。</p>
<p><img src="hexo-default.png" alt="hexo-default"></p>
<h2 id="创建Github-Page的仓库"><a href="#创建Github-Page的仓库" class="headerlink" title="创建Github Page的仓库"></a>创建Github Page的仓库</h2><p>登录自己的Github账号，创建一个仓库，命名规则如下。</p>
<p><code>&lt;username&gt;.github.io</code></p>
<p>这里的username是你的github账户名，创建成功后，你可以试着往里面存一个Index.html，随后访问&lt;username&gt;.github.io，应该就会显示你放进去的index.html渲染内容。</p>
<h2 id="简单配置一下Hexo"><a href="#简单配置一下Hexo" class="headerlink" title="简单配置一下Hexo"></a>简单配置一下Hexo</h2><p>现在博客里只有一篇默认的文章“Hello World”，同时页面的标题、作者等信息都是预设的，可以通过_config.yml进行一些简单的配置，并将网站部署到Github Page上。</p>
<p>用记事本打开项目根目录下的_config.yml，找到Site配置项。</p>
<p><code># Site</code></p>
<p><code>title: Hexo（即html的title标签）</code></p>
<p><code>subtitle: &#39;&#39;（副标题）</code></p>
<p><code>description: &#39;&#39;（页面的简介，可在搜索引擎上显示出来）</code></p>
<p><code>keywords:（关键字词）</code></p>
<p><code>author: John Doe（作者名）</code></p>
<p><code>language: en（语言，中文是zh-Hans）</code></p>
<p><code>timezone: &#39;&#39;（时区，中国地区是Asia/Shanghai）</code></p>
<p>默认配置应该像上面这样，自己修改掉需要的条目即可。</p>
<p>然后找到Deployment配置项。</p>
<p><code>deploy:  </code></p>
<p>​    <code>type: git  </code></p>
<p>​    <code>   repo: &lt;repository url&gt; </code></p>
<p>​    <code>branch: [branch]</code></p>
<p>type填git，repo填你的Github项目SSH地址或者Https地址，branch是分支名（一般master就行）。</p>
<p>完成以上配置后，就可以保存退出了。</p>
<h2 id="部署到Github-Page上"><a href="#部署到Github-Page上" class="headerlink" title="部署到Github Page上"></a>部署到Github Page上</h2><p>在项目根目录下使用下列命令安装hexo的部署插件。</p>
<p><code>npm install hexo-deployer-git --save</code></p>
<p>使用hexo clean &amp;&amp; hexo deploy即可将现有的Hexo项目部署到Github Page上，访问你的github.io即可查看，注意部署上去一般是需要一到两分钟的，在此之前你访问页面可能看不到效果。</p>
<h1 id="后文"><a href="#后文" class="headerlink" title="后文"></a>后文</h1><p>到这里位置，Github Page+Hexo的博客搭建指南就结束了，但重头戏还没开始呢，怎么发文章？碰到报错了怎么办？怎么进一步对Hexo配置？怎么更换Hexo主题？上面这些问题就留着后面说吧，应该会很快更新的。</p>
<h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><p><a href="https://pages.github.com/">Github Pages官方指南</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/33720429">npm使用淘宝镜像</a></p>
<p><a href="https://hexo.io/zh-cn/docs/">hexo官方文档</a></p>
]]></content>
      <categories>
        <category>Hexo博客系列</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>使用两种遍历结果构造二叉树</title>
    <url>/2021/03/26/%E4%BD%BF%E7%94%A8%E4%B8%A4%E7%A7%8D%E9%81%8D%E5%8E%86%E7%BB%93%E6%9E%9C%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<p>最近刷Leetcode时，遇到了一道题，给你一个二叉树的后序遍历和中序遍历的输入序列，如何把这棵树的结构构造出来？</p>
<p>下面贴出这道题的原地址<a href="https://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/">从中序与后续遍历序列构造二叉树</a>。</p>
<h1 id="后序遍历和中序遍历的特点"><a href="#后序遍历和中序遍历的特点" class="headerlink" title="后序遍历和中序遍历的特点"></a>后序遍历和中序遍历的特点</h1><p>不管是先序、中序、后序，它们的不同点在于访问根节点的时机，先序先访问根节点、后序最后访问根节点。</p>
<p>来看看原题给的样例。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">中序遍历 inorder = [<span class="number">9</span>,<span class="number">3</span>,<span class="number">15</span>,<span class="number">20</span>,<span class="number">7</span>]</span><br><span class="line">后序遍历 postorder = [<span class="number">9</span>,<span class="number">15</span>,<span class="number">7</span>,<span class="number">20</span>,<span class="number">3</span>]</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  <span class="number">3</span></span><br><span class="line"> / \</span><br><span class="line"><span class="number">9</span>  <span class="number">20</span></span><br><span class="line">  /  \</span><br><span class="line"> <span class="number">15</span>   <span class="number">7</span></span><br></pre></td></tr></table></figure>

<p>来观察一下，可以发现中序遍历的一个特征：在中序遍历的序列中，根节点左边是左子树，根节点右边是右子树。中序遍历序列从前往后看的规律是：左子树-&gt;根节点-&gt;右子树。</p>
<p>也可以发现后序遍历的一个特征：左子树的叶子节点最先找到，右子树的叶子节点次之，根节点最后找到。比如后序遍历最后一个元素为3，再看看后序遍历倒数第二个元素20，它是根节点3的右子树，20再往前的元素7则是20的右子树，那么后序遍历的规律很明朗了，从遍历序列后往前看，根节点-&gt;右子树-&gt;左子树。</p>
<p>这个遍历的性质很重要，如此一来就可以通过分治算法来将遍历结果转换为二叉树。</p>
<h1 id="分而治之"><a href="#分而治之" class="headerlink" title="分而治之"></a>分而治之</h1><p>根据上面二叉树的性质，可以先通过后序遍历的最后一个元素找到根节点3，然后去中序遍历中找到根节点3，找到以后就可以将3左边的元素判定为左子树，3右边的元素判定为右子树。</p>
<p><img src="1.png" alt="1"></p>
<p>然后先递归地对右子树进行处理（因为我们看后序遍历是从后面往前看的），再递归地对左子树进行处理，得到地就是完整地二叉树。</p>
<h1 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] inorder,postorder;</span><br><span class="line">	<span class="keyword">int</span> postIndex;<span class="comment">//记录后序遍历当前位置</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//在中序遍历中l和r下标之间寻找tar这个元素</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findIndexForNum</span><span class="params">(<span class="keyword">int</span> tar,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=l;i&lt;=r;i++) &#123;</span><br><span class="line">			<span class="keyword">if</span>(inorder[i]==tar) &#123;</span><br><span class="line">				<span class="keyword">return</span> i;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//建树的递归函数,l和r是当前子树在中序遍历中的范围</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> TreeNode <span class="title">build</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(l&gt;r) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> midVal=postorder[postIndex--];<span class="comment">//从后序遍历中拿一个根节点</span></span><br><span class="line">		TreeNode root=<span class="keyword">new</span> TreeNode(midVal);</span><br><span class="line">		<span class="keyword">int</span> midIndex=findIndexForNum(midVal,l,r);</span><br><span class="line">		root.right=build(midIndex+<span class="number">1</span>,r);<span class="comment">//先建右子树</span></span><br><span class="line">		root.left=build(l,midIndex-<span class="number">1</span>);</span><br><span class="line">		<span class="keyword">return</span> root;</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">	<span class="function"><span class="keyword">public</span> TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>[] inorder, <span class="keyword">int</span>[] postorder)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.inorder=inorder;</span><br><span class="line">		<span class="keyword">this</span>.postorder=postorder;</span><br><span class="line">		postIndex=postorder.length-<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">return</span> build(<span class="number">0</span>,postIndex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="用中序和先序遍历构造二叉树"><a href="#用中序和先序遍历构造二叉树" class="headerlink" title="用中序和先序遍历构造二叉树"></a>用中序和先序遍历构造二叉树</h1><p>其实道理也是一样的，只不过变成了从前往后遍历先序序列，具体做法仍然是分治+递归建树。</p>
]]></content>
      <categories>
        <category>算法</category>
        <category>二叉树</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>二叉树</tag>
        <tag>二叉树遍历</tag>
        <tag>递归</tag>
        <tag>分治</tag>
      </tags>
  </entry>
  <entry>
    <title>千岛湖的首次接触</title>
    <url>/2021/05/04/%E5%8D%83%E5%B2%9B%E6%B9%96%E7%9A%84%E9%A6%96%E6%AC%A1%E6%8E%A5%E8%A7%A6/</url>
    <content><![CDATA[<h1 id="旅游概览"><a href="#旅游概览" class="headerlink" title="旅游概览"></a>旅游概览</h1><ul>
<li>时间：2021年5月1日-2021年5月3日</li>
<li>人数：4（4个大老爷们，本科室友）</li>
<li>预算：人均1000左右</li>
<li>出行方式：高铁，非自驾游</li>
</ul>
<h1 id="出发前的准备"><a href="#出发前的准备" class="headerlink" title="出发前的准备"></a>出发前的准备</h1><p>实际上五一前两周的时候，我们几个就语音会议了几次，罗列了一下从网上搜集到的信息，包括景点（免费或收费）、住宿、饮食等，自以为准备的挺好的，然而计划赶不上变化，到了地方才发现，有些东西跟搜集到的信息不同，又或者误判了千岛湖那边的情况，总之有不满意的地方，但总体上还是比较令人愉悦的（自我欺骗）…</p>
<p>这里就不一一展示我们前期调查的成果了，如果有需要的话，知乎上许多大佬都总结了千岛湖旅游攻略，这里推介一下我参考过的几篇文章。</p>
<ul>
<li><a href="https://zhuanlan.zhihu.com/p/267175880">去了不下十次千岛湖，带来这份超全的秋游攻略</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/71137483">千岛湖游记+攻略</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/346414685">去了2次千岛湖，总结了一下千岛湖红黑榜</a></li>
</ul>
<p>来千岛湖旅游，如果不想失望而归，最好还是得做下前期调查，这很重要，因为景点质量层次不齐。</p>
<h1 id="5月1日"><a href="#5月1日" class="headerlink" title="5月1日"></a>5月1日</h1><p>我们订的是中午12点多的高铁票，从杭州东出发到富阳，中间不下车，到了千岛湖补票，全程大概就一个多小时；而从千岛湖站到我们住的地方路程还是挺远的，打了车大概半小时到一小时的路程。</p>
<h2 id="啤酒小镇"><a href="#啤酒小镇" class="headerlink" title="啤酒小镇"></a>啤酒小镇</h2><p>抵达预订的民宿时大概就两点半，地点就离啤酒小镇几百米路程，于是就决定当天下午把物品放到房间里直接去啤酒小镇逛一逛。</p>
<p>门口大概是这样的，这地方建筑风格还是很明显的，能一眼认出来。</p>
<p><img src="dlhj_pic.jpg" alt="1"></p>
<p>啤酒小镇这地方可以理解为一个小规模的娱乐城，速度快的话，半小时内就能逛完，但白天人很少，很多商铺–主要是餐厅都是晚上开门。</p>
<p>实我们来啤酒小镇主要是为了体验卡丁车，从啤酒小镇正门进去走到底就能看到卡丁车场，实际上这个卡丁车是套餐其中一个项目，包括皮划艇、热气球、蹦床、滑翔伞、卡丁车、啤酒博物馆等，整个项目的价格是300多，完整游玩需要一整天；或者也可以单独只买卡丁车的门票，价格100多，场地里玩的人好像还是挺少的，大部分人都是在卡丁车场门口围观，我感觉主要是因为这个卡丁车的入门门槛比较高，因为光买门票还不行，你得签保险、接受简单的培训等等一系列，反正我们几个立刻丧失兴趣了…</p>
<h2 id="千岛湖森林氧吧"><a href="#千岛湖森林氧吧" class="headerlink" title="千岛湖森林氧吧"></a>千岛湖森林氧吧</h2><p>由于白天啤酒小镇这边并没有啥娱乐项目，我们立刻就闪人了，此时大概下午三点出头，看了下时间，距离千岛湖森林氧吧关门大概还剩三个小时左右，我们下一站就去了那里。</p>
<p>话说前期调查的时候我一直以为千岛湖森林氧吧这个地方应该是跟杭州九溪类似的一个地方，有一些人工痕迹，但大多数景观应该保持自然，然而现实狠狠抽了我的脸。</p>
<p>千岛湖森林氧吧的位置离市区比较远，接近湖区最东边，我们从啤酒小镇出来以后立刻就前往了，路程大概十公里以内，打车半小时以内，门票大概55元/人。</p>
<p><img src="forest_bar.jpg" alt="2"></p>
<p>上图是我从网上找的比较接近实景的图，我印象里光线还要更暗一点，总之是个阴间景点…</p>
<p>如果要我用一个词概括这地方来体验啥的话，爬山……没错，所谓森林氧吧就是爬山，而且还是一座海拔不到300米的山……</p>
<p>顺便从网上找了一张景点路线图。</p>
<p><img src="6.jpg" alt="6"></p>
<p>我罗列几个关键词，各位读者可以感受一下：五一人多、山路窄、昏暗、宰客，总之这个景点要多阴间有多阴间，绝对不会再去第二次。下山时，想上个厕所，结果唯一看到的那个厕所居然奇臭无比，顿时让我对这个景点的好感度下降到负值……</p>
<p>爬山过程中，我们4人唯一的乐趣就是打屁聊天。顺带一提，下山的时候可以看到一个滑草和滑车，都是可以快速下山的，但不幸的是，都是要钱的，依稀记得二三十元一人，极其搞笑。</p>
<p><img src="3.jpg" alt="孔雀"></p>
<p>这里的孔雀和兔子是我们下山时发现的，依稀记得是一个叫“孔雀摄影”的商铺，可能是花点钱让你跟孔雀合影的吧，总之几只小动物反而是整个千岛湖氧吧为数不多的亮点。</p>
<p><img src="4.jpg" alt="兔子"></p>
<p>下山的时候路过一个叫“裸足戏水”的景点，我们顺便轮流拍了几张照。</p>
<p><img src="5.png" alt="me"></p>
<p>总而言之，千岛湖森林氧吧这个景点，我们一致认为是这三天逛的最不值的景点，55块钱爬了一座海拔300米不到的山。</p>
<h2 id="鱼宴馆"><a href="#鱼宴馆" class="headerlink" title="鱼宴馆"></a>鱼宴馆</h2><p>从森林氧吧出来，大概已经下午18点多了，我们去的餐厅是前期调查的时候找到的一个餐厅，叫“鱼宴馆”，毕竟来千岛湖，肯定得专门吃一顿千岛湖鱼头吧。这家餐厅应该算是比较有人气的农家菜，打车前往餐厅前，我们已经订了座位，但由于堵车，还是迟到了，我们到的时候门口已经有好多人在排队，所幸又等了半个多小时，重新排到了我们。</p>
<p>首先必点的菜肯定是浓汤鱼头，先放一张图感受一下。</p>
<p><img src="7.jpg" alt="7"></p>
<p>我个人是不太喜欢吃鱼的，不过既然来了千岛湖，一定要体验一下当地的特色，我这张图里看起来鱼只露出一小部分，实际上鱼的大部分都在汤里，鱼个头还是挺大的，肉量也多，但我最喜欢的还是这个汤，味道比较“鲜”，两个人吃估计想吃完够呛，我们四人差不多刚好能吃完，所以我估计这道菜应该是3-4人的量。</p>
<p>其他的菜，小炒肉、土猪肉、石锅豆腐等都还是不错的，但一般餐桌上总有一道菜是多余的，这道菜我没记错的话应该叫玉米片，从知乎上找了一张图，大概是这样。</p>
<p><img src="8.jpg" alt="8"></p>
<p>这道菜口感挺脆的，跟薯片有点像，但比薯片还要更脆一点，它的问题就是味道太淡了，没有薯片的命，得了薯片的病。</p>
<h1 id="插曲"><a href="#插曲" class="headerlink" title="插曲"></a>插曲</h1><p>吃完晚饭，4人都有点撑，于是决定逛一下，由于鱼宴馆正好就在千岛湖岸边，我们就决定绕千岛湖逛一下。</p>
<p>讲道理，千岛湖的夜景并不好，千岛湖这边政府要求环境保护非常严格，大晚上除了千岛湖岸边上的街道是开灯的，湖中心是根本不开灯的，所以沿着千岛湖夜游啥也看不到……</p>
<p>所以晚上回到民宿前，我们4人都是打屁聊天。唯一的亮点是一个岸边的婚纱照拍摄现场，4人纷纷表达了对未来婚礼的憧憬，可惜天太黑，啥照片也没拍就回去了。</p>
<p>由于第二天我们决定是去东南湖区上岛游玩，考虑到岛上的水和食物等必然贵，我们决定提前去超市买点吃喝，最终买了点八宝粥、果冻、蛋黄派之类的。</p>
<h1 id="5月2日"><a href="#5月2日" class="headerlink" title="5月2日"></a>5月2日</h1><p>第二天天气特别好，大晴天，我们预定是去东南湖区坐船上岛，早上大概9点多出门，早餐吃的非常撑，因为中午只是吃点蛋黄派充饥。</p>
<p>从民宿出发到东南湖区大概就10公里的路程，到了那边以后，大概十点左右，在门口买票的人说不上多，一开始我们打算网上买票，结果五月二号的票全部都卖完了，所以只好排队窗口买票。</p>
<p>东南湖区这边上岛主要分两种票，快艇和游艇，价格其实差不了多少，快艇大概是七八个人一起乘坐，而游艇是两层的，大概几十个人一起乘坐，我们坐的是游艇二层，一开始还挺新鲜的，毕竟湖面上吹来的风非常凉快，大家都跑到甲板上吹风拍照，但转船以后明显就没那个新鲜劲了，因为说实话，湖面上确实啥都没有，太阳也比较大。要我说，还是快艇比较有趣，每当附近有快艇乘风破浪驶过，我们几个都会投去羡慕的眼神。</p>
<p><img src="9.jpg" alt="9"></p>
<h2 id="黄山尖"><a href="#黄山尖" class="headerlink" title="黄山尖"></a>黄山尖</h2><p>算是糟糕一天的开始吧，因为，黄山尖也是一座山…..上下山都有缆车可以坐，票价大概是二十多一人，还算比较值，不过我们一行人上山是爬上去的。</p>
<p>山脚大概几十米的地方有个小卖部，挺多人在这边休息，我问了一下，一根热狗卖15块钱，瞬间放弃了在这边买东西的想法。</p>
<p>黄山尖和千岛湖森林氧吧作比较的话，爬山体验无疑是黄山尖全方位碾压千岛湖森林氧吧的，因为上山台阶还是相对宽敞的，而且光线也比较足，人工痕迹相比于后者也没有那么令人反感。</p>
<p>黄山尖这边一个看点是，山顶向湖面俯瞰，可以看到几个小岛组成的“公”字，一开始我们在船上时，导游跟我们说是“天下为公”几个大字，但恕我眼拙，只看到一个“公”字。</p>
<p><img src="10.jpg" alt="10"></p>
<p>由于前一天爬森林氧吧就有点累了，爬完黄山尖以后，我们几个人都比较累，于是下山的的时候，坐了缆车。</p>
<h2 id="天池岛"><a href="#天池岛" class="headerlink" title="天池岛"></a>天池岛</h2><p>我们的游览门票只有两个岛，黄山尖游览完后就是天池岛，这座岛地势相对平坦一些，看点也比黄山尖多。</p>
<p>首先是天池，实际上就是一个小鱼塘，里面有许多大大小小的金鱼，门口有收费的投喂鱼食。这些鱼又肥又胖，很明显就是天天被游客喂出来的……</p>
<p><img src="11.jpg" alt="11"></p>
<p><img src="18.jpg" alt="18"></p>
<p>天池岛面积还是比较大的，另一个看点就是鸟岛，顾名思义，这地方主要是看鸟的，可以看到鹦鹉不少鹦鹉、天鹅、火烈鸟，还有一个鹦鹉表演。</p>
<p>出去的路上我们经过一个鸟园，不过门口有告示，由于近期整改升级，鸟园暂时没开放，只在外面看到一只呆滞的鸵鸟，还有个小屁孩拿小块的食物残渣扔它，结果它一点反应也没有，突然就感觉鸟岛的这些鸟真是可怜，被束缚了起来，放弃了挣扎。</p>
<p><img src="12.jpg" alt="12"></p>
<p>从鸟岛到终点二号码头的路上，还能看到几处不错的风景。</p>
<p><img src="13.jpg" alt="13"></p>
<p><img src="14.jpg" alt="14"></p>
<p><img src="15.jpg" alt="15"></p>
<p><img src="16.jpg" alt="16"></p>
<p><img src="17.jpg" alt="17"></p>
<p>由于黄山尖爬完已经比较累了，导致我们游玩天池岛时，兴致不高，速度非常快地就上船回码头了。</p>
<h2 id="晚上的小插曲"><a href="#晚上的小插曲" class="headerlink" title="晚上的小插曲"></a>晚上的小插曲</h2><p>第二天晚上我们是去啤酒小镇吃的，原本是想吃烤羊腿，结果老板跟我们说至少要排队等一个半小时以上，于是我们只好去了一家旁边人少的小餐馆吃了点，仍然是农家菜，跟前一天鱼宴馆的菜品相比，没啥特别的。</p>
<p>原本是想吃完饭去听听啤酒小镇音乐节，结果噪音实在太大，我们忍受不了，就直接回去休息了。</p>
<p>关于我们住的民宿，有一点需要吐槽的地方，就是wifi速度极其感人，无论你是开流量还是连他们的wifi，用网高峰期的速度连个B站的视频都看不了，只有深夜的时候速度稍微快一些。我们只能玩玩带过来的三国杀实体卡牌，不过还是挺欢乐的，两天晚上都是三国杀打发时间，一盘一个小时，时间还是过挺快的。</p>
<h1 id="5月3日"><a href="#5月3日" class="headerlink" title="5月3日"></a>5月3日</h1><p>最后一天就是退房，由于是下午四点半的票，我们也没有再去哪个新的景点游览，中午去市区吃了顿韩式烤肉，KTV唱了两个多小时，就坐动车回杭州了。</p>
<h1 id="旅游体感"><a href="#旅游体感" class="headerlink" title="旅游体感"></a>旅游体感</h1><p>千岛湖这个地方，我觉得并不适合一个人游览，因为很多景点确实也就那样，不如跟朋友聊天打发时间，如果你没来过的话，还是建议做一下旅游规划。我们这两天的旅游，主要感受就是累，因为都是在爬山、走路。</p>
<p>今后如果还要来千岛湖的话，我应该会尝试一下天宇山观景台、漂流等更有乐趣的项目。</p>
<p>五一假期主要还是调整一下心态，毕业后脑子里一直是工作的事情，根本没有机会放松一下自己的心态，这次几个大学室友一起出去玩，仿佛又回到了毕业前，还是挺开心的。</p>
]]></content>
      <categories>
        <category>随笔</category>
        <category>游记</category>
      </categories>
      <tags>
        <tag>随笔</tag>
        <tag>游记</tag>
      </tags>
  </entry>
  <entry>
    <title>我的第一篇文章</title>
    <url>/2021/02/10/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0/</url>
    <content><![CDATA[<p>自从毕业后一直想弄一个个人博客，一开始是想自己搭一个站点部署到吃灰的阿里云上，后来发现其实没必要，毕竟Github上都那么多现成的博客生成框架了，况且Github Pages也不会因为自己的服务器到期而产生数据迁移的烦恼。</p>
<p>最近这几天知乎上逛了一下，了解到现在有个Node.js的项目hexo，很适合用来搭建博客，仔细了解了一下，发现用它搭建静态博客确实比较方便，本着回馈互联网的原则，我打算下一篇文章就写写自己怎么搭建的这个Github Page。</p>
<p>总之，之前日思夜想的博客总算是搞起来了，后续如果有什么有趣、有用的东西，可能都会发到这上面来吧，虽然不一定有人看。</p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>如何让hexo个人博客被搜索引擎收录</title>
    <url>/2021/03/10/%E5%A6%82%E4%BD%95%E8%AE%A9hexo%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E8%A2%AB%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E%E6%94%B6%E5%BD%95/</url>
    <content><![CDATA[<p>之前发过几篇博客，讲了如何使用hexo这个框架生成静态博客页面，在<a href="https://blog.zenoxen.cn/2021/02/14/%E5%AF%B9%E5%8D%9A%E5%AE%A2%E5%B8%83%E5%B1%80%E8%BF%9B%E8%A1%8C%E4%B8%AA%E6%80%A7%E5%8C%96%E5%AE%9A%E5%88%B6/">hexo博客的定制化</a>这篇文章里也讲了我自己对Hexo博客是如何定制的，包括怎么启用评论、浏览量功能。<br>但如果大家都不知道你的博客，那评论也没啥意义了吧，这篇文章就讲一讲我自己是怎么让谷歌和百度收录我的博客的。</p>
<h1 id="Github-Pages的一个问题"><a href="#Github-Pages的一个问题" class="headerlink" title="Github Pages的一个问题"></a>Github Pages的一个问题</h1><p>如果你直接尝试让百度去收录你的github pages的话，会发现一个问题，百度抓取不到github pages的地址，由于历史原因，github把百度的爬虫给禁用了，所以虽然github pages是真的好用，但还是得忍痛割爱，换个路子。</p>
<h1 id="使用Vercel网站托管服务"><a href="#使用Vercel网站托管服务" class="headerlink" title="使用Vercel网站托管服务"></a>使用Vercel网站托管服务</h1><p>有很多网站提供静态网站托管服务，我试过Coding.net和vercel这两个，coding.net的托管服务是依托于腾讯云的，很早以前是免费的，但现在貌似有一定限制了，具体什么情况我有点记不清了；后来试了vercel，它也能提供免费的静态网站托管服务，而且操作起来比coding.net舒服，目前是免费的，这是它的官网<a href="https://vercel.com/">vercel</a>。</p>
<h2 id="vercel如何与github联动"><a href="#vercel如何与github联动" class="headerlink" title="vercel如何与github联动"></a>vercel如何与github联动</h2><p>进入vercel，可以使用github账号登录。<br><img src="1.png" alt="1"><br>coding.net与vercel都可以从github上导入repository，但vercel比coding.net好的一点在于第一次与github关联并授权以后，你以后往github上push的任何更改，都会同步到vercel上，而coding.net并不能这样（虽然可以通过hexo的deploy配置往coding.net自动部署）。<br>在vercel上选择New Project，然后如果你是用Github账号登录的话，这边会显示你的所有Github仓库，选择github pages的仓库即可。<br><img src="2.png" alt="2"><br>中间导入的几个步骤就不截图了，按默认设置一直点下一步即可。最后成功导入后应该可以看到congratulations，点击那个visit就可以查看托管在vercel上的网站了。<br><img src="3.png" alt="3"><br>这里有一点要注意的是，虽然内容与github pages上部署的那个网页一模一样，但vercel是一个独立的副本，只不过每次github pages那个仓库更新的时候，会同步更新到vercel这边而已。</p>
<h2 id="使用自己的域名"><a href="#使用自己的域名" class="headerlink" title="使用自己的域名"></a>使用自己的域名</h2><p>在你的vercel项目这边找到settings项。<br><img src="4.png" alt="4"><br>点击Domains项，可以看到里面有一条默认的域名项，这是vercel提供给你免费使用的，如果你的项目名没改的话，一般就是github里那个仓库名为前缀，看起来怪怪的，你可以自己点击edit来修改域名记录，注意一下，vercel.app是固定的域名，不要改掉，你可以改的是这个vercel.app前面那一堆。<br><img src="5.png" alt="5"></p>
<p>到这里为止，实际上你已经拥有了一个与Github Pages不同的独立域名，即vercel.app，但如果你既想通过Vercel来部署博客站点，又想脱离vercel.app这个域名的话，唯一的方法就是买一个自己的域名了。我自己是通过阿里云买的域名，一个cn域名，第一年优惠很大，买下域名10块钱不到，所以比较建议买一个，过期了以后续不续倒是无所谓，早买早享受。</p>
<p>假设你已经买了一个自己的域名，那么仍然点击vercel这边的Domains项，输入你自己的域名，记住要带上主机记录，比如我的域名是zenoxen.cn，那么你在输入自己域名的时候，最好加一个主机记录，比如<a href="www.zenoxen.cn">www.zenoxen.cn</a>或者<a href="blog.zenoxen.cn">blog.zenoxen.cn</a>，主机记录具体是什么倒无所谓。</p>
<p><img src="6.png" alt="6"></p>
<p>这里假设我加的记录是<a href="www.zenoxen.cn">www.zenoxen.cn</a>，结果发现了一个Invalid Configuration的错误。</p>
<p><img src="7.png" alt="7"></p>
<p>这实际上是因为没有将zenoxen.cn这个域名的www主机记录指向vercel服务器而造成的，换句话说，就是现在还每法通过<a href="www.zenoxen.cn">www.zenoxen.cn</a>来访问部署在vercel服务器的这个博客应用。一个比较简单的解决办法是给zenoxen.cn这个域名设置一个CNAME记录，将其指向vercel的服务器域名。</p>
<p><img src="8.png" alt="8"></p>
<p>CNAME记录在你买域名的代理商那边就可以设置，比如我是在阿里云那边买的，那么我去阿里云那边找域名控制台。</p>
<p><img src="9.png" alt="9"></p>
<p>添加vercel提供的那条CNAME记录，指向<a href="www.zenoxen.cn">www.zenoxen.cn</a>。</p>
<p><img src="10.png" alt="10"></p>
<p>如此一来，那边自动就会检测到<a href="www.zenoxen.cn">www.zenoxen.cn</a>已经指向了vercel服务器，Invalid Configuration的报错也会消失了。</p>
<h1 id="搜索引擎收录"><a href="#搜索引擎收录" class="headerlink" title="搜索引擎收录"></a>搜索引擎收录</h1><p>接下来的一步就是让搜索引擎收录你的博客，无论你是使用vercel的域名，还是使用自己的域名，理应都可以被搜索引擎收录了。</p>
<p>实际上大部分搜索引擎收录流程都是类似的，我自己提交过Google和百度，方式都是大同小异的。</p>
<p>主流的搜索引擎都有几种收录方式：API推送、提交Sitemap、手动提交，这里简单介绍一下。</p>
<h2 id="API推送"><a href="#API推送" class="headerlink" title="API推送"></a>API推送</h2><p>API推送是在页面里嵌入这样一串js代码，调用这个api的作用是把当前这个页面提交给搜索引擎，所以在每个页面里都嵌入这样的代码，就可以实现全站的推送。</p>
<p><img src="11.png" alt="11"></p>
<p>这里就以百度为例，展示一下如何使用API来让百度收录我们的博客。</p>
<p>首先进入<a href="https://ziyuan.baidu.com/">百度站长平台</a>,选择菜单栏上的用户中心，站点管理，添加网站。</p>
<p><img src="14.png" alt="14"></p>
<p>随后选择协议头，并输入你的主机记录，比如我的域名是zenoxen.cn，主机记录是<a href="www.zenoxen.cn">www.zenoxen.cn</a>。</p>
<p><img src="15.png" alt="15"></p>
<p>第二步选择站点属性其实不重要，按你的博客性质勾选即可。</p>
<p>第三步选择一个验证方式，这里验证的是你对域名与站点的所有权，我们选HTML标签验证，然后把百度提供给你的那一串html标签记下来，准确的来说，是记那一串content，即验证码。</p>
<p><img src="16.png" alt="16"></p>
<p>接下来就是将百度的验证码嵌入hexo页面中，如果你跟我一样用的是next主题，那么最新的next主题配置文件里应该包含了这样的配置信息，将baidu_site_verification修改为百度给你的验证码即可，无需将整个html标签嵌入到某个页面中，next主题会自动帮我们完成这个工作。</p>
<p><img src="17.png" alt="17"></p>
<p>这边添加完后，使用hexo clean&amp;&amp;hexo g&amp;&amp;hexo d，将页面重新部署到你的vercel中去，部署完成后，即可点击百度那边的完成验证。</p>
<p><img src="18.png" alt="18"></p>
<p>完成验证后，从菜单里选择普通收录，然后就是收录的环节了，点击API推送，记下百度给你的API地址。</p>
<p>在hexo项目根目录安装hexo-baidu-url-submit，运行下列命令即可。</p>
<p><code>npm install hexo-baidu-url-submit</code></p>
<p>在hexo根目录的_config,yml文件中，加入这些配置，count是一次性提交的url数量，你可以根据自己页面数量来决定，但百度每天都有3000条url的提交上限，这个要注意一下，host是你在百度添加的主机记录，token是从百度给你API地址中取出来的即url中的token参数，path是生成的url文件路径，这个不用改名，baidu_urls.txt即可。</p>
<p><img src="19.png" alt="19"></p>
<p>最后在deploy中加入下列配置，这样你每次使用hexo d的时候，hexo-baidu-submit都会将生成的baidu_urls.txt提交给百度。</p>
<p><img src="20.png" alt="20"></p>
<p>执行部署一条龙命令，如果最后出现了下面这种信息，说明已经成功将页面提交给百度了。</p>
<p><img src="21.png" alt="21"></p>
<p>正常来说，第二天之内，在百度站长平台就可以发现你前一天成功提交的记录了，但要注意的是提交成功了不代表百度就会收录你的网页，从提交成功到收录成功，这个时间可能很长（据说几周到几个月都有），这也是我觉得百度不如谷歌的一点，百度收录效率真的没谷歌高…</p>
<h2 id="Sitemap"><a href="#Sitemap" class="headerlink" title="Sitemap"></a>Sitemap</h2><p>Sitemap一般来说是一种xml文件，其中包含的是一个站点的结构，比如这是我博客的Sitemap。</p>
<p><img src="12.png" alt="12"></p>
<p>可以看到，Sitemap里包含了站点中所有的页面的url，Sitemap推送的原理是将你的Sitemap文件放在站点根目录下，然后让搜索引擎到你的站点取Sitemap，如此搜索引擎就可以根据Sitemap来了解你的站点结构了。</p>
<p>我之前尝试过用baidu的sitemap提交，一开始几次百度都成功读取了我的sitemap，但后来不知道啥原因，百度那边显示无法读取我的sitemap了，所以后来百度我换了API提交。所幸的是，谷歌的sitemap一直没有出过问题。</p>
<p>谷歌的提交是通过<a href="https://search.google.com/search-console/about">search console</a>，添加站点和验证站点的操作其实跟百度差不多，都是使用HTML标签认证，这里就不深入介绍了。讲讲怎么让hexo自动生成sitemap，并提交给谷歌。</p>
<p>首先在你的hexo项目根目录下安装hexo-generator-sitemap，使用下面命令即可。</p>
<p><code>npm install hexo-generator-sitemap</code></p>
<p>安装完这个插件后，在根目录下的_config.yml中加入以下配置。</p>
<p><img src="22.png" alt="22"></p>
<p>随后你就可以执行hexo clean&amp;&amp;hexo g了，正常的话，应该会在public目录下产生一个sitemap.xml，确认生成了以后，就hexo d，将项目部署到vercel上。</p>
<p>此时，你去访问站点根目录的sitemap.xml应该就可以直接看到xml的内容，比如我的博客sitemap，可以通过<a href="https://blog.zenoxen.cn/sitemap.xml">https://blog.zenoxen.cn/sitemap.xml</a>来进行查看。</p>
<p><img src="23.png" alt="23"></p>
<p>然后在谷歌的search console中添加站点地图即可，成功添加后，谷歌应该会在几天之内读取你的sitemap，从sitemap读取成功到收录成功，效率之高是百度没法比的…我自己的站点，谷歌只用了一天就完成收录，真的很快。</p>
<h2 id="手动提交"><a href="#手动提交" class="headerlink" title="手动提交"></a>手动提交</h2><p>从名字就可以看出，手动提交是个比较繁琐的过程，需要你自己手动将站点里的页面url提交到搜索引擎里，我实际上没用过这种提交方式，不过操作应该是将你的页面url一个一个的复制粘贴给搜索引擎，让它逐个收录。</p>
<h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><p><a href="https://blog.csdn.net/liutao43/article/details/106324954/">hexo设置主动推送</a><br><a href="https://zhuanlan.zhihu.com/p/111773896">如何让百度收录 GitHub Pages 个人博客</a></p>
]]></content>
      <categories>
        <category>Hexo博客系列</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>
